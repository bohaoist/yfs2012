!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACQUIRING	lock_client_cache.h	/^	enum lock_state {NONE, FREE, LOCKED, ACQUIRING, RELEASING};$/;"	e	enum:lock_client_cache::lock_state
BUSY	rsm_protocol.h	/^  enum xxstatus { OK, ERR, BUSY};$/;"	e	enum:rsm_protocol::xxstatus
BUSY	rsm_protocol.h	/^  enum xxstatus { OK, ERR, NOTPRIMARY, BUSY};$/;"	e	enum:rsm_client_protocol::xxstatus
CB_MASK	rpc/pollmgr.h	/^	CB_MASK = ~0x11,$/;"	e	enum:__anon5
CB_NONE	rpc/pollmgr.h	/^	CB_NONE = 0x0,$/;"	e	enum:__anon5
CB_RDONLY	rpc/pollmgr.h	/^	CB_RDONLY = 0x1,$/;"	e	enum:__anon5
CB_RDWR	rpc/pollmgr.h	/^	CB_RDWR = 0x11,$/;"	e	enum:__anon5
CB_WRONLY	rpc/pollmgr.h	/^	CB_WRONLY = 0x10,$/;"	e	enum:__anon5
CC	GNUmakefile	/^CC = g++$/;"	m
CLOCK_MONOTONIC	gettime.cc	/^	CLOCK_MONOTONIC,$/;"	e	enum:__anon2	file:
CLOCK_MONOTONIC	gettime.h	/^	CLOCK_MONOTONIC,$/;"	e	enum:__anon1
CLOCK_PROCESS_CPUTIME_ID	gettime.cc	/^	CLOCK_PROCESS_CPUTIME_ID,$/;"	e	enum:__anon2	file:
CLOCK_PROCESS_CPUTIME_ID	gettime.h	/^	CLOCK_PROCESS_CPUTIME_ID,$/;"	e	enum:__anon1
CLOCK_REALTIME	gettime.cc	/^	CLOCK_REALTIME,$/;"	e	enum:__anon2	file:
CLOCK_REALTIME	gettime.h	/^	CLOCK_REALTIME,$/;"	e	enum:__anon1
CLOCK_THREAD_CPUTIME_ID	gettime.cc	/^	CLOCK_THREAD_CPUTIME_ID$/;"	e	enum:__anon2	file:
CLOCK_THREAD_CPUTIME_ID	gettime.h	/^	CLOCK_THREAD_CPUTIME_ID$/;"	e	enum:__anon1
CXX	GNUmakefile	/^CXX = g++$/;"	m
CXXFLAGS	GNUmakefile	/^CXXFLAGS =  -g -MMD -Wall -I. -I$(RPC) -DLAB=$(LAB) -DSOL=$(SOL) -D_FILE_OFFSET_BITS=64$/;"	m
DEFAULT_RPC_SZ	rpc/marshall.h	/^	DEFAULT_RPC_SZ = 1024,$/;"	e	enum:__anon7
DONE	rpc/rpc.h	/^		DONE, \/\/ duplicate of an RPC we already replied to (have reply)$/;"	e	enum:rpcs::__anon6
EPollAIO	rpc/pollmgr.cc	/^EPollAIO::EPollAIO()$/;"	f	class:EPollAIO
EPollAIO	rpc/pollmgr.h	/^class EPollAIO : public aio_mgr {$/;"	c
ERR	paxos_protocol.h	/^  enum xxstatus { OK, ERR };$/;"	e	enum:paxos_protocol::xxstatus
ERR	rsm_protocol.h	/^  enum xxstatus { OK, ERR, BUSY};$/;"	e	enum:rsm_protocol::xxstatus
ERR	rsm_protocol.h	/^  enum xxstatus { OK, ERR, NOTPRIMARY, BUSY};$/;"	e	enum:rsm_client_protocol::xxstatus
ERR	rsm_protocol.h	/^  enum xxstatus { OK, ERR};$/;"	e	enum:rsm_test_protocol::xxstatus
EXIST	yfs_client.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR, EXIST };$/;"	e	enum:yfs_client::xxstatus
FAILURE	config.h	/^    FAILURE,	\/\/ no response$/;"	e	enum:config::__anon3
FORGOTTEN	rpc/rpc.h	/^		FORGOTTEN,  \/\/ duplicate of an old RPC whose reply we've forgotten$/;"	e	enum:rpcs::__anon6
FREE	lock_client_cache.h	/^	enum lock_state {NONE, FREE, LOCKED, ACQUIRING, RELEASING};$/;"	e	enum:lock_client_cache::lock_state
FREE	lock_protocol.h	/^    enum lock_status {FREE, LOCKED};$/;"	e	enum:lock::lock_status
FREE	lock_server_cache.h	/^	enum lock_state {FREE, LOCKED, LOCKED_AND_WAIT, RETRYING};$/;"	e	enum:lock_server_cache::lock_state
FUSEFLAGS	GNUmakefile	/^FUSEFLAGS= -D_FILE_OFFSET_BITS=64 -DFUSE_USE_VERSION=25 -I\/usr\/local\/include\/fuse -I\/usr\/include\/fuse$/;"	m
INPROGRESS	rpc/rpc.h	/^		INPROGRESS, \/\/ duplicate of an RPC we're still processing$/;"	e	enum:rpcs::__anon6
IOERR	extent_protocol.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR };$/;"	e	enum:extent_protocol::xxstatus
IOERR	lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	e	enum:lock_protocol::xxstatus
IOERR	yfs_client.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR, EXIST };$/;"	e	enum:yfs_client::xxstatus
Instance	rpc/pollmgr.cc	/^PollMgr::Instance()$/;"	f	class:PollMgr
JSL_DBG_1	rpc/jsl_log.h	/^	JSL_DBG_1 = 1, \/\/ Critical$/;"	e	enum:dbcode
JSL_DBG_2	rpc/jsl_log.h	/^	JSL_DBG_2 = 2, \/\/ Error$/;"	e	enum:dbcode
JSL_DBG_3	rpc/jsl_log.h	/^	JSL_DBG_3 = 3, \/\/ Info$/;"	e	enum:dbcode
JSL_DBG_4	rpc/jsl_log.h	/^	JSL_DBG_4 = 4, \/\/ Debugging$/;"	e	enum:dbcode
JSL_DBG_OFF	rpc/jsl_log.h	/^	JSL_DBG_OFF = 0,$/;"	e	enum:dbcode
JSL_DEBUG_LEVEL	rpc/jsl_log.cc	/^int JSL_DEBUG_LEVEL = 0;$/;"	v
LAB	GNUmakefile	/^LAB=7$/;"	m
LAB2GE	GNUmakefile	/^LAB2GE=$(shell expr $(LAB) \\>\\= 2)$/;"	m
LAB3GE	GNUmakefile	/^LAB3GE=$(shell expr $(LAB) \\>\\= 3)$/;"	m
LAB4GE	GNUmakefile	/^LAB4GE=$(shell expr $(LAB) \\>\\= 4)$/;"	m
LAB5GE	GNUmakefile	/^LAB5GE=$(shell expr $(LAB) \\>\\= 5)$/;"	m
LAB6GE	GNUmakefile	/^LAB6GE=$(shell expr $(LAB) \\>\\= 6)$/;"	m
LAB7GE	GNUmakefile	/^LAB7GE=$(shell expr $(LAB) \\>\\= 7)$/;"	m
LDFLAGS	GNUmakefile	/^LDFLAGS = -L. -L\/usr\/local\/lib$/;"	m
LDLIBS	GNUmakefile	/^LDLIBS = -lpthread $/;"	m
LOCKED	lock_client_cache.h	/^	enum lock_state {NONE, FREE, LOCKED, ACQUIRING, RELEASING};$/;"	e	enum:lock_client_cache::lock_state
LOCKED	lock_protocol.h	/^    enum lock_status {FREE, LOCKED};$/;"	e	enum:lock::lock_status
LOCKED	lock_server_cache.h	/^	enum lock_state {FREE, LOCKED, LOCKED_AND_WAIT, RETRYING};$/;"	e	enum:lock_server_cache::lock_state
LOCKED_AND_WAIT	lock_server_cache.h	/^	enum lock_state {FREE, LOCKED, LOCKED_AND_WAIT, RETRYING};$/;"	e	enum:lock_server_cache::lock_state
MACFLAGS	GNUmakefile	/^  MACFLAGS= -D__FreeBSD__=10$/;"	m
MACFLAGS	GNUmakefile	/^  MACFLAGS=$/;"	m
MAX_PDU	rpc/connection.cc	17;"	d	file:
MAX_POLL_FDS	rpc/pollmgr.h	11;"	d
MODIFIED	extent_client.h	/^	enum file_state {NONE,UPDATED, MODIFIED, REMOVED};$/;"	e	enum:extent_client_cache::file_state
NEW	rpc/rpc.h	/^		NEW,  \/\/ new RPC, not a duplicate$/;"	e	enum:rpcs::__anon6
NOENT	extent_protocol.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR };$/;"	e	enum:extent_protocol::xxstatus
NOENT	lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	e	enum:lock_protocol::xxstatus
NOENT	yfs_client.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR, EXIST };$/;"	e	enum:yfs_client::xxstatus
NONE	extent_client.h	/^	enum file_state {NONE,UPDATED, MODIFIED, REMOVED};$/;"	e	enum:extent_client_cache::file_state
NONE	lock_client_cache.h	/^	enum lock_state {NONE, FREE, LOCKED, ACQUIRING, RELEASING};$/;"	e	enum:lock_client_cache::lock_state
NOTPRIMARY	rsm_protocol.h	/^  enum xxstatus { OK, ERR, NOTPRIMARY, BUSY};$/;"	e	enum:rsm_client_protocol::xxstatus
NUM_CL	rpc/rpctest.cc	15;"	d	file:
OK	config.h	/^    OK,	\/\/ response and same view #$/;"	e	enum:config::__anon3
OK	extent_protocol.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR };$/;"	e	enum:extent_protocol::xxstatus
OK	lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	e	enum:lock_protocol::xxstatus
OK	lock_protocol.h	/^  enum xxstatus { OK, RPCERR };$/;"	e	enum:rlock_protocol::xxstatus
OK	paxos_protocol.h	/^  enum xxstatus { OK, ERR };$/;"	e	enum:paxos_protocol::xxstatus
OK	rsm_protocol.h	/^  enum xxstatus { OK, ERR, BUSY};$/;"	e	enum:rsm_protocol::xxstatus
OK	rsm_protocol.h	/^  enum xxstatus { OK, ERR, NOTPRIMARY, BUSY};$/;"	e	enum:rsm_client_protocol::xxstatus
OK	rsm_protocol.h	/^  enum xxstatus { OK, ERR};$/;"	e	enum:rsm_test_protocol::xxstatus
OK	yfs_client.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR, EXIST };$/;"	e	enum:yfs_client::xxstatus
PollMgr	rpc/pollmgr.cc	/^PollMgr::PollMgr() : pending_change_(false)$/;"	f	class:PollMgr
PollMgr	rpc/pollmgr.h	/^class PollMgr {$/;"	c
PollMgrInit	rpc/pollmgr.cc	/^PollMgrInit()$/;"	f
RELEASING	lock_client_cache.h	/^	enum lock_state {NONE, FREE, LOCKED, ACQUIRING, RELEASING};$/;"	e	enum:lock_client_cache::lock_state
REMOVED	extent_client.h	/^	enum file_state {NONE,UPDATED, MODIFIED, REMOVED};$/;"	e	enum:extent_client_cache::file_state
RETRY	lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	e	enum:lock_protocol::xxstatus
RETRYING	lock_server_cache.h	/^	enum lock_state {FREE, LOCKED, LOCKED_AND_WAIT, RETRYING};$/;"	e	enum:lock_server_cache::lock_state
RPC	GNUmakefile	/^RPC=.\/rpc$/;"	m
RPCERR	extent_protocol.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR };$/;"	e	enum:extent_protocol::xxstatus
RPCERR	lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	e	enum:lock_protocol::xxstatus
RPCERR	lock_protocol.h	/^  enum xxstatus { OK, RPCERR };$/;"	e	enum:rlock_protocol::xxstatus
RPCERR	yfs_client.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR, EXIST };$/;"	e	enum:yfs_client::xxstatus
RPC_HEADER_SZ	rpc/marshall.h	/^	RPC_HEADER_SZ = static_max<sizeof(req_header), sizeof(reply_header)>::value + sizeof(rpc_sz_t) + sizeof(rpc_checksum_t)$/;"	e	enum:__anon7
RSM	lock_smain.cc	50;"	d	file:
SOL	GNUmakefile	/^SOL=0$/;"	m
STEP_ONE	lock_smain.cc	53;"	d	file:
ScopedLock	rpc/slock.h	/^		ScopedLock(pthread_mutex_t *m): m_(m) {$/;"	f	struct:ScopedLock
ScopedLock	rpc/slock.h	/^struct ScopedLock {$/;"	s
ScopedLockClient	yfs_client.h	/^		ScopedLockClient(lock_client *lc, lock_protocol::lockid_t lid):$/;"	f	class:ScopedLockClient
ScopedLockClient	yfs_client.h	/^class ScopedLockClient {$/;"	c
SelectAIO	rpc/pollmgr.cc	/^SelectAIO::SelectAIO() : highfds_(0)$/;"	f	class:SelectAIO
SelectAIO	rpc/pollmgr.h	/^class SelectAIO : public aio_mgr {$/;"	c
TO	rpc/rpc.h	/^		struct TO {$/;"	s	class:rpcc
TPRINTF_H	tprintf.h	2;"	d
ThrPool	rpc/thr_pool.cc	/^ThrPool::ThrPool(int sz, bool blocking)$/;"	f	class:ThrPool
ThrPool	rpc/thr_pool.h	/^class ThrPool {$/;"	c
UPDATED	extent_client.h	/^	enum file_state {NONE,UPDATED, MODIFIED, REMOVED};$/;"	e	enum:extent_client_cache::file_state
VERIFY	lang/verify.h	10;"	d
VERIFY	lang/verify.h	12;"	d
VIEWERR	config.h	/^    VIEWERR,	\/\/ response but different view #$/;"	e	enum:config::__anon3
XXX	rpc/method_thread.h	/^		class XXX {$/;"	c	namespace:__anon4
__JSL_LOG_H__	rpc/jsl_log.h	2;"	d
__SCOPED_LOCK__	rpc/slock.h	2;"	d
__THR_POOL__	rpc/thr_pool.h	2;"	d
__clock_gettime_inf	gettime.cc	/^static mach_timebase_info_data_t __clock_gettime_inf;$/;"	v	file:
_buf	rpc/marshall.h	/^		char *_buf;     \/\/ Base of the raw bytes buffer (dynamically readjusted)$/;"	m	class:marshall
_buf	rpc/marshall.h	/^		char *_buf;$/;"	m	class:unmarshall
_capa	rpc/marshall.h	/^		int _capa;      \/\/ Capacity of the buffer$/;"	m	class:marshall
_ind	rpc/marshall.h	/^		int _ind;       \/\/ Read\/write head position$/;"	m	class:marshall
_ind	rpc/marshall.h	/^		int _ind;$/;"	m	class:unmarshall
_ok	rpc/marshall.h	/^		bool _ok;$/;"	m	class:unmarshall
_sz	rpc/marshall.h	/^		int _sz;$/;"	m	class:unmarshall
a	lock_tester.cc	/^lock_protocol::lockid_t a = 1;$/;"	v
a	rpc/thr_pool.h	/^			void *a; \/\/function arguments$/;"	m	struct:ThrPool::job_t
a1	rpc/method_thread.h	/^				A1 a1;$/;"	m	class:__anon4::XXX
a2	rpc/method_thread.h	/^				A2  a2;$/;"	m	class:__anon4::XXX
acc	config.h	/^  acceptor *acc;$/;"	m	class:config
acc	paxos.h	/^  acceptor *acc;$/;"	m	class:proposer
accept	paxos.cc	/^proposer::accept(unsigned instance, std::vector<std::string> &accepts,$/;"	f	class:proposer
accept	paxos_protocol.h	/^    bool accept;$/;"	m	struct:paxos_protocol::prepareres
accept_conn	rpc/connection.cc	/^tcpsconn::accept_conn()$/;"	f	class:tcpsconn
acceptarg	paxos_protocol.h	/^  struct acceptarg {$/;"	s	class:paxos_protocol
acceptor	paxos.cc	/^acceptor::acceptor(class paxos_change *_cfg, bool _first, std::string _me, $/;"	f	class:acceptor
acceptor	paxos.h	/^class acceptor {$/;"	c
acceptreq	paxos.cc	/^acceptor::acceptreq(std::string src, paxos_protocol::acceptarg a, bool &r)$/;"	f	class:acceptor
acceptreq	paxos_protocol.h	/^    acceptreq,$/;"	e	enum:paxos_protocol::rpc_numbers
acquire	lock_client.cc	/^lock_client::acquire(lock_protocol::lockid_t lid)$/;"	f	class:lock_client
acquire	lock_client_cache.cc	/^lock_client_cache::acquire(lock_protocol::lockid_t lid)$/;"	f	class:lock_client_cache
acquire	lock_client_cache_rsm.cc	/^lock_client_cache_rsm::acquire(lock_protocol::lockid_t lid)$/;"	f	class:lock_client_cache_rsm
acquire	lock_protocol.h	/^    acquire = 0x7001,$/;"	e	enum:lock_protocol::rpc_numbers
acquire	lock_server.cc	/^lock_server::acquire(int clt, lock_protocol::lockid_t lid, int &r)$/;"	f	class:lock_server
acquire	lock_server_cache.cc	/^int lock_server_cache::acquire(lock_protocol::lockid_t lid, std::string id, $/;"	f	class:lock_server_cache
acquire	lock_server_cache_rsm.cc	/^int lock_server_cache_rsm::acquire(lock_protocol::lockid_t lid, std::string id, $/;"	f	class:lock_server_cache_rsm
add	config.cc	/^config::add(std::string new_m, unsigned vid)$/;"	f	class:config
addJob	rpc/thr_pool.cc	/^ThrPool::addJob(void *(*f)(void *), void *a)$/;"	f	class:ThrPool
addObjJob	rpc/thr_pool.h	/^ThrPool::addObjJob(C *o, void (C::*m)(A), A a)$/;"	f	class:ThrPool
add_callback	rpc/pollmgr.cc	/^PollMgr::add_callback(int fd, poll_flag flag, aio_callback *ch)$/;"	f	class:PollMgr
add_reply	rpc/rpc.cc	/^rpcs::add_reply(unsigned int clt_nonce, unsigned int xid,$/;"	f	class:rpcs
add_timespec	rpc/rpc.cc	/^add_timespec(const struct timespec &a, int b, struct timespec *result)$/;"	f
aio_	rpc/pollmgr.h	/^		aio_mgr *aio_;$/;"	m	class:PollMgr
aio_callback	rpc/pollmgr.h	/^class aio_callback {$/;"	c
aio_mgr	rpc/pollmgr.h	/^class aio_mgr {$/;"	c
algorithm_h	lang/algorithm.h	4;"	d
amiprimary	rsm.cc	/^rsm::amiprimary()$/;"	f	class:rsm
append	test-lab-2-b.pl	/^sub append {$/;"	s
append1	test-lab-3-b.c	/^append1(const char *d, const char *f, const char *in)$/;"	f
append1	test-lab-3-c.c	/^append1(const char *d, const char *f, const char *in)$/;"	f
atime	extent_protocol.h	/^    unsigned int atime;$/;"	m	struct:extent_protocol::attr
atime	yfs_client.h	/^    unsigned long atime;$/;"	m	struct:yfs_client::dirinfo
atime	yfs_client.h	/^    unsigned long atime;$/;"	m	struct:yfs_client::fileinfo
atmostonce_failure	rpc/rpc.h	/^		static const int atmostonce_failure = -4;$/;"	m	class:rpc_const
attr	extent_client.h	/^		extent_protocol::attr attr;$/;"	m	struct:extent_client_cache::extent
attr	extent_protocol.h	/^  struct attr {$/;"	s	class:extent_protocol
attr	extent_server.h	/^	extent_protocol::attr attr;$/;"	m	struct:extent_server::extent
attr	rpc/rpctest.cc	/^pthread_attr_t attr;$/;"	v
attr_	rpc/thr_pool.h	/^		pthread_attr_t attr_;$/;"	m	class:ThrPool
b	lock_tester.cc	/^lock_protocol::lockid_t b = 2;$/;"	v
backups	rsm.h	/^  std::vector<std::string> backups;   \/\/ A list of unsynchronized backups$/;"	m	class:rsm
big	test-lab-3-b.c	/^char big[20001];$/;"	v
bind	rpc/rpc.cc	/^rpcc::bind(TO to)$/;"	f	class:rpcc
bind	rpc/rpc.h	/^		static const unsigned int bind = 1;   \/\/ handler number reserved for bind$/;"	m	class:rpc_const
bind_done_	rpc/rpc.h	/^		bool bind_done_;$/;"	m	class:rpcc
bind_failure	rpc/rpc.h	/^		static const int bind_failure = -6;$/;"	m	class:rpc_const
block_remove_fd	rpc/pollmgr.cc	/^PollMgr::block_remove_fd(int fd)$/;"	f	class:PollMgr
blockadd_	rpc/thr_pool.h	/^		bool blockadd_;$/;"	m	class:ThrPool
break1	paxos.h	/^  bool break1;$/;"	m	class:proposer
break1	rsm.h	/^  bool break1;$/;"	m	class:rsm
break2	paxos.h	/^  bool break2;$/;"	m	class:proposer
break2	rsm.h	/^  bool break2;$/;"	m	class:rsm
breakpoint	config.h	/^  void breakpoint(int b) { pro->breakpoint(b); }$/;"	f	class:config
breakpoint	paxos.cc	/^proposer::breakpoint(int b)$/;"	f	class:proposer
breakpoint	rsm_protocol.h	/^    breakpoint = 0x12002,$/;"	e	enum:rsm_test_protocol::rpc_numbers
breakpoint	rsmtest_client.cc	/^rsmtest_client::breakpoint(int b)$/;"	f	class:rsmtest_client
breakpoint1	paxos.cc	/^proposer::breakpoint1()$/;"	f	class:proposer
breakpoint1	rsm.cc	/^rsm::breakpoint1()$/;"	f	class:rsm
breakpoint2	paxos.cc	/^proposer::breakpoint2()$/;"	f	class:proposer
breakpoint2	rsm.cc	/^rsm::breakpoint2()$/;"	f	class:rsm
breakpointreq	rsm.cc	/^rsm::breakpointreq(int b, int &r)$/;"	f	class:rsm
buf	rpc/connection.h	/^			char *buf;$/;"	m	struct:connection::charbuf
buf	rpc/rpc.h	/^		char *buf;      \/\/ the reply buffer$/;"	m	struct:rpcs::reply_t
buf	rpc/rpc.h	/^		char *buf;$/;"	m	struct:rpcs::djob_t
buf	rpc/rpc.h	/^                    std::string buf;$/;"	m	struct:rpcc::request
bundle	rpc/connection.h	/^	bundle(chanmgr *m, int s, int l):mgr(m),tcp(s),lossy(l) {}$/;"	f	struct:bundle
bundle	rpc/connection.h	/^struct bundle {$/;"	s
c	lock_tester.cc	/^lock_protocol::lockid_t c = 3;$/;"	v
c	rpc/rpc.h	/^			pthread_cond_t c;$/;"	m	struct:rpcc::caller
call	rpc/rpc.h	/^rpcc::call(unsigned int proc, R & r, TO to) $/;"	f	class:rpcc
call	rpc/rpc.h	/^rpcc::call(unsigned int proc, const A1 & a1, R & r, TO to) $/;"	f	class:rpcc
call	rpc/rpc.h	/^rpcc::call(unsigned int proc, const A1 & a1, const A2 & a2,$/;"	f	class:rpcc
call	rsm_client.h	/^  rsm_client::call(unsigned int proc, const A1 & a1, $/;"	f	class:rsm_client
call	rsm_client.h	/^  rsm_client::call(unsigned int proc, const A1 & a1, R & r)$/;"	f	class:rsm_client
call	rsm_client.h	/^  rsm_client::call(unsigned int proc, const A1 & a1, const A2 & a2, R & r)$/;"	f	class:rsm_client
call1	rpc/rpc.cc	/^rpcc::call1(unsigned int proc, marshall &req, unmarshall &rep,$/;"	f	class:rpcc
call_m	rpc/rpc.h	/^rpcc::call_m(unsigned int proc, marshall &req, R & r, TO to) $/;"	f	class:rpcc
call_m	rsm_client.h	/^rsm_client::call_m(unsigned int proc, marshall &req, R &r)$/;"	f	class:rsm_client
callbacks_	rpc/pollmgr.h	/^		aio_callback *callbacks_[MAX_POLL_FDS];$/;"	m	class:PollMgr
caller	rpc/rpc.cc	/^rpcc::caller::caller(unsigned int xxid, unmarshall *xun)$/;"	f	class:rpcc::caller
caller	rpc/rpc.h	/^		struct caller {$/;"	s	class:rpcc
calls_	rpc/rpc.h	/^		std::map<int, caller *> calls_;$/;"	m	class:rpcc
cancel	rpc/rpc.cc	/^rpcc::cancel(void)$/;"	f	class:rpcc
cancel_failure	rpc/rpc.h	/^		static const int cancel_failure = -7;$/;"	m	class:rpc_const
cb_present	rpc/rpc.h	/^		bool cb_present; \/\/ whether the reply buffer is valid$/;"	m	struct:rpcs::reply_t
cfg	paxos.h	/^  paxos_change *cfg;$/;"	m	class:acceptor
cfg	paxos.h	/^  paxos_change *cfg;$/;"	m	class:proposer
cfg	rsm.h	/^  config *cfg;$/;"	m	class:rsm
cfg_mutex	config.h	/^  pthread_mutex_t cfg_mutex;$/;"	m	class:config
chan_	rpc/rpc.h	/^		connection *chan_;$/;"	m	class:rpcc
chan_m_	rpc/rpc.h	/^		pthread_mutex_t chan_m_;$/;"	m	class:rpcc
changedone_c_	rpc/pollmgr.h	/^		pthread_cond_t changedone_c_;$/;"	m	class:PollMgr
chanmgr	rpc/connection.h	/^class chanmgr {$/;"	c
channo	rpc/connection.h	/^		int channo() { return fd_; }$/;"	f	class:connection
charbuf	rpc/connection.h	/^			charbuf (char *b, int s) : buf(b), sz(s), solong(0){}$/;"	f	struct:connection::charbuf
charbuf	rpc/connection.h	/^			charbuf(): buf(NULL), sz(0), solong(0) {}$/;"	f	struct:connection::charbuf
charbuf	rpc/connection.h	/^		struct charbuf {$/;"	s	class:connection
check1	test-lab-3-b.c	/^check1(const char *d, const char *f, const char *in)$/;"	f
check1	test-lab-3-c.c	/^check1(const char *d, const char *f, const char *in)$/;"	f
check_grant	lock_tester.cc	/^check_grant(lock_protocol::lockid_t lid)$/;"	f
check_release	lock_tester.cc	/^check_release(lock_protocol::lockid_t lid)$/;"	f
check_views	rsm_tester.pl	/^sub check_views {$/;"	s
checkcontent	test-lab-2-b.pl	/^sub checkcontent {$/;"	s
checkdirmtime	test-lab-3-a.pl	/^sub checkdirmtime {$/;"	s
checkduplicate_and_update	rpc/rpc.cc	/^rpcs::checkduplicate_and_update(unsigned int clt_nonce, unsigned int xid,$/;"	f	class:rpcs
checkmtime	test-lab-3-a.pl	/^sub checkmtime {$/;"	s
checkn	test-lab-3-b.c	/^checkn(const char *d, const char *prefix, int nf)$/;"	f
checkn	test-lab-3-c.c	/^checkn(const char *d, const char *prefix, int nf)$/;"	f
checknot	test-lab-2-b.pl	/^sub checknot {$/;"	s
checknot	test-lab-3-b.c	/^checknot(const char *d, const char *f)$/;"	f
checknot	test-lab-3-c.c	/^checknot(const char *d, const char *f)$/;"	f
checkread	test-lab-3-b.c	/^checkread(const char *d, const char *f, int start, int n, char c)$/;"	f
cl	extent_client.h	/^  rpcc *cl;$/;"	m	class:extent_client
cl	handle.h	/^  rpcc *cl;$/;"	m	struct:hinfo
cl	lock_client.h	/^  rpcc *cl;$/;"	m	class:lock_client
cl	rsmtest_client.h	/^  rpcc *cl;$/;"	m	class:rsmtest_client
cl_mutex	handle.h	/^  pthread_mutex_t cl_mutex;$/;"	m	struct:hinfo
clean_files	GNUmakefile	/^clean_files=rpc\/rpctest rpc\/*.o rpc\/*.d rpc\/librpc.a *.o *.d yfs_client extent_server lock_server lock_tester lock_demo rpctest test-lab-3-b test-lab-3-c rsm_tester$/;"	m
cleanup	rsm_tester.pl	/^sub cleanup {$/;"	s
cleanup	test-lab-3-a.pl	/^sub cleanup {$/;"	s
clear	rpc/rpc.h	/^                    void clear() { buf.clear(); xid = -1; }$/;"	f	struct:rpcc::request
client1	rpc/rpctest.cc	/^client1(void *xx)$/;"	f
client2	rpc/rpctest.cc	/^client2(void *xx)$/;"	f
client3	rpc/rpctest.cc	/^client3(void *xx)$/;"	f
client_invoke	rsm.cc	/^rsm::client_invoke(int procno, std::string req, std::string &r)$/;"	f	class:rsm
client_members	rsm.cc	/^rsm::client_members(int i, std::vector<std::string> &r)$/;"	f	class:rsm
client_mutex	lock_client_cache.h	/^	pthread_mutex_t client_mutex; $/;"	m	class:lock_client_cache
clients	rpc/rpctest.cc	/^rpcc *clients[NUM_CL];  \/\/ client rpc object$/;"	v
clock_gettime	gettime.cc	/^int clock_gettime(clockid_t clk_id, struct timespec *tp) {$/;"	f
clock_gettime	gettime.cc	65;"	d	file:
clockid_t	gettime.cc	/^} clockid_t;$/;"	t	typeref:enum:__anon2	file:
clockid_t	gettime.h	/^} clockid_t;$/;"	t	typeref:enum:__anon1
closeconn	rpc/connection.cc	/^connection::closeconn()$/;"	f	class:connection
clt_nonce	rpc/marshall.h	/^	unsigned int clt_nonce;$/;"	m	struct:req_header
clt_nonce_	rpc/rpc.h	/^		unsigned int clt_nonce_;$/;"	m	class:rpcc
cmp_timespec	rpc/rpc.cc	/^cmp_timespec(const struct timespec &a, const struct timespec &b)$/;"	f
commit	paxos.cc	/^acceptor::commit(unsigned instance, std::string value)$/;"	f	class:acceptor
commit_change	rsm.cc	/^rsm::commit_change(unsigned vid) $/;"	f	class:rsm
commit_change_wo	rsm.cc	/^rsm::commit_change_wo(unsigned vid) $/;"	f	class:rsm
commit_wo	paxos.cc	/^acceptor::commit_wo(unsigned instance, std::string value)$/;"	f	class:acceptor
compar	test-lab-3-b.c	/^compar(const void *xa, const void *xb)$/;"	f
compar	test-lab-3-c.c	/^compar(const void *xa, const void *xb)$/;"	f
compare	rpc/connection.cc	/^connection::compare(connection *another)$/;"	f	class:connection
concurrent_test	rpc/rpctest.cc	/^concurrent_test(int nt)$/;"	f
config	config.cc	/^config::config(std::string _first, std::string _me, config_view_change *_vc) $/;"	f	class:config
config	config.h	/^class config : public paxos_change {$/;"	c
config_cond	config.h	/^  pthread_cond_t config_cond;$/;"	m	class:config
config_h	config.h	2;"	d
config_view_change	config.h	/^class config_view_change {$/;"	c
conn	rpc/rpc.h	/^		connection *conn;$/;"	m	struct:rpcs::djob_t
connect_to_dst	rpc/connection.cc	/^connect_to_dst(const sockaddr_in &dst, chanmgr *mgr, int lossy)$/;"	f
connection	rpc/connection.cc	/^connection::connection(chanmgr *m1, int f1, int l1) $/;"	f	class:connection
connection	rpc/connection.h	/^class connection : public aio_callback {$/;"	c
connection_h	rpc/connection.h	2;"	d
conns_	rpc/connection.h	/^		std::map<int, connection *> conns_;$/;"	m	class:tcpsconn
conns_	rpc/rpc.h	/^	std::map<unsigned int, connection *> conns_;$/;"	m	class:rpcs
conss_m_	rpc/rpc.h	/^	pthread_mutex_t conss_m_; \/\/ protect conns_$/;"	m	class:rpcs
count_m_	rpc/rpc.h	/^	pthread_mutex_t count_m_;  \/\/protect modification of counts$/;"	m	class:rpcs
count_mutex	lock_tester.cc	/^pthread_mutex_t count_mutex;$/;"	v
counting_	rpc/rpc.h	/^	const int counting_;$/;"	m	class:rpcs
counts_	rpc/rpc.h	/^	std::map<int, int> counts_;$/;"	m	class:rpcs
create	yfs_client.cc	/^yfs_client::create(inum parent, const char *name, inum &inum)$/;"	f	class:yfs_client
create1	test-lab-3-b.c	/^create1(const char *d, const char *f, const char *in)$/;"	f
create1	test-lab-3-c.c	/^create1(const char *d, const char *f, const char *in)$/;"	f
create_time_	rpc/connection.h	/^                struct timeval create_time_;$/;"	m	class:connection	typeref:struct:connection::timeval
createagain	test-lab-2-a.pl	/^sub createagain {$/;"	s
createn	test-lab-3-b.c	/^createn(const char *d, const char *prefix, int nf, bool possible_dup)$/;"	f
createn	test-lab-3-c.c	/^createn(const char *d, const char *prefix, int nf)$/;"	f
createone	test-lab-2-a.pl	/^sub createone {$/;"	s
createone	test-lab-3-a.pl	/^sub createone {$/;"	s
cstr	rpc/marshall.h	/^		char *cstr() { return _buf;}$/;"	f	class:marshall
cstr	rpc/marshall.h	/^		char *cstr() { return _buf;}$/;"	f	class:unmarshall
ct	lock_tester.cc	/^int ct[256];$/;"	v
ctime	extent_protocol.h	/^    unsigned int ctime;$/;"	m	struct:extent_protocol::attr
ctime	yfs_client.h	/^    unsigned long ctime;$/;"	m	struct:yfs_client::dirinfo
ctime	yfs_client.h	/^    unsigned long ctime;$/;"	m	struct:yfs_client::fileinfo
curr_counts_	rpc/rpc.h	/^	int curr_counts_;$/;"	m	class:rpcs
d1	test-lab-3-b.c	/^char d1[512], d2[512];$/;"	v
d1	test-lab-3-c.c	/^char d1[512], d2[512];$/;"	v
d2	test-lab-3-b.c	/^char d1[512], d2[512];$/;"	v
d2	test-lab-3-c.c	/^char d1[512], d2[512];$/;"	v
data	extent_client.h	/^		std::string data;$/;"	m	struct:extent_client_cache::extent
data	extent_server.h	/^	std::string data;$/;"	m	struct:extent_server::extent
dbcode	rpc/jsl_log.h	/^enum dbcode {$/;"	g
dead_	rpc/connection.h	/^		bool dead_;$/;"	m	class:connection
deadcheck	test-lab-2-a.pl	/^sub deadcheck {$/;"	s
deadcheck	test-lab-3-a.pl	/^sub deadcheck {$/;"	s
decide	paxos.cc	/^proposer::decide(unsigned instance, std::vector<std::string> accepts, $/;"	f	class:proposer
decidearg	paxos_protocol.h	/^  struct decidearg {$/;"	s	class:paxos_protocol
decidereq	paxos.cc	/^acceptor::decidereq(std::string src, paxos_protocol::decidearg a, int &r)$/;"	f	class:acceptor
decidereq	paxos_protocol.h	/^    decidereq,$/;"	e	enum:paxos_protocol::rpc_numbers
decref	rpc/connection.cc	/^connection::decref()$/;"	f	class:connection
del	handle.h	/^  bool del;$/;"	m	struct:hinfo
del_callback	rpc/pollmgr.cc	/^PollMgr::del_callback(int fd, poll_flag flag)$/;"	f	class:PollMgr
delete_handle	handle.cc	/^handle_mgr::delete_handle(std::string m)$/;"	f	class:handle_mgr
delete_handle_wo	handle.cc	/^handle_mgr::delete_handle_wo(std::string m)$/;"	f	class:handle_mgr
deleteone	test-lab-2-a.pl	/^sub deleteone {$/;"	s
deleteone	test-lab-3-a.pl	/^sub deleteone {$/;"	s
deq	rpc/fifo.h	/^fifo<T>::deq(T *e)$/;"	f	class:fifo
destroy_wait_	rpc/rpc.h	/^		bool destroy_wait_;$/;"	m	class:rpcc
destroy_wait_c_	rpc/rpc.h	/^		pthread_cond_t destroy_wait_c_;$/;"	m	class:rpcc
diff_timespec	rpc/rpc.cc	/^diff_timespec(const struct timespec &end, const struct timespec &start)$/;"	f
dirbuf	fuse.cc	/^struct dirbuf {$/;"	s	file:
dirbuf_add	fuse.cc	/^void dirbuf_add(struct dirbuf *b, const char *name, fuse_ino_t ino)$/;"	f
dircheck	test-lab-2-a.pl	/^sub dircheck {$/;"	s
dircheck	test-lab-2-b.pl	/^sub dircheck {$/;"	s
dircheck	test-lab-3-a.pl	/^sub dircheck {$/;"	s
dircheck	test-lab-3-b.c	/^dircheck(const char *d, int nf)$/;"	f
dircheck	test-lab-3-c.c	/^dircheck(const char *d, int nf)$/;"	f
dirent	yfs_client.h	/^  struct dirent {$/;"	s	class:yfs_client
dirinfo	yfs_client.h	/^  struct dirinfo {$/;"	s	class:yfs_client
dispatch	rpc/rpc.cc	/^rpcs::dispatch(djob_t *j)$/;"	f	class:rpcs
dispatchpool_	rpc/rpc.h	/^	ThrPool* dispatchpool_;$/;"	m	class:rpcs
djob_t	rpc/rpc.h	/^		djob_t (connection *c, char *b, int bsz):buf(b),sz(bsz),conn(c) {}$/;"	f	struct:rpcs::djob_t
djob_t	rpc/rpc.h	/^	struct djob_t {$/;"	s	class:rpcs
do_worker	rpc/thr_pool.cc	/^do_worker(void *arg)$/;"	f	file:
doheartbeat	config.cc	/^config::doheartbeat(std::string m)$/;"	f	class:config
done	rpc/rpc.h	/^			bool done;$/;"	m	struct:rpcc::caller
done_handle	handle.cc	/^handle_mgr::done_handle(struct hinfo *h)$/;"	f	class:handle_mgr
dopartition	rsm.h	/^  bool dopartition;$/;"	m	class:rsm
dorelease	yfs_client.h	/^		void dorelease(lock_protocol::lockid_t lid) {$/;"	f	class:lock_user
dst	lock_demo.cc	/^std::string dst;$/;"	v
dst	lock_tester.cc	/^std::string dst;$/;"	v
dst	rpc/rpctest.cc	/^struct sockaddr_in dst; \/\/server's ip address$/;"	v	typeref:struct:sockaddr_in
dst_	rpc/rpc.h	/^		sockaddr_in dst_;$/;"	m	class:rpcc
dump	config.h	/^  std::string dump() { return acc->dump(); };$/;"	f	class:config
dump	log.cc	/^log::dump()$/;"	f	class:log
dump	paxos.cc	/^acceptor::dump()$/;"	f	class:acceptor
dup_req_	rpc/rpc.h	/^                struct request dup_req_;$/;"	m	class:rpcc	typeref:struct:rpcc::request
ec	yfs_client.h	/^       extent_client_cache *ec;$/;"	m	class:lock_user
ec	yfs_client.h	/^  extent_client *ec;$/;"	m	class:yfs_client
enq	rpc/fifo.h	/^fifo<T>::enq(T e, bool blocking)$/;"	f	class:fifo
execute	rsm.cc	/^rsm::execute(int procno, std::string req, std::string &r)$/;"	f	class:rsm
extent	extent_client.h	/^		extent():status(NONE) {}$/;"	f	struct:extent_client_cache::extent
extent	extent_client.h	/^	struct extent {$/;"	s	class:extent_client_cache
extent	extent_server.h	/^ struct extent {$/;"	s	class:extent_server
extent_client	extent_client.cc	/^extent_client::extent_client(std::string dst)$/;"	f	class:extent_client
extent_client	extent_client.h	/^class extent_client {$/;"	c
extent_client_cache	extent_client.h	/^class extent_client_cache : public extent_client {$/;"	c
extent_client_cache	extent_client_cache.cc	/^extent_client_cache::extent_client_cache(std::string dst)$/;"	f	class:extent_client_cache
extent_client_h	extent_client.h	4;"	d
extent_mutex	extent_client.h	/^		pthread_mutex_t extent_mutex; $/;"	m	class:extent_client_cache
extent_protocol	extent_protocol.h	/^class extent_protocol {$/;"	c
extent_protocol_h	extent_protocol.h	4;"	d
extent_server	GNUmakefile	/^extent_server=extent_server.cc extent_smain.cc$/;"	m
extent_server	extent_server.cc	/^extent_server::extent_server() {$/;"	f	class:extent_server
extent_server	extent_server.h	/^class extent_server {$/;"	c
extent_server_h	extent_server.h	4;"	d
extentid_t	extent_protocol.h	/^  typedef unsigned long long extentid_t;$/;"	t	class:extent_protocol
f	rpc/thr_pool.h	/^			void *(*f)(void *); \/\/function point$/;"	m	struct:ThrPool::job_t
failure_test	rpc/rpctest.cc	/^failure_test()$/;"	f
fd_	rpc/connection.h	/^		const int fd_;$/;"	m	class:connection
fdstatus_	rpc/pollmgr.h	/^		int fdstatus_[MAX_POLL_FDS];$/;"	m	class:EPollAIO
fifo	rpc/fifo.h	/^class fifo {$/;"	c
fifo	rpc/fifo.h	/^fifo<T>::fifo(int limit) : max_(limit)$/;"	f	class:fifo
fifo_h	rpc/fifo.h	2;"	d
file_cached	extent_client.h	/^		std::map <extent_protocol::extentid_t, extent>file_cached;$/;"	m	class:extent_client_cache
file_map	extent_server.h	/^  std::map<extent_protocol::extentid_t, extent> file_map;$/;"	m	class:extent_server
file_state	extent_client.h	/^	enum file_state {NONE,UPDATED, MODIFIED, REMOVED};$/;"	g	class:extent_client_cache
fileinfo	yfs_client.h	/^  struct fileinfo {$/;"	s	class:yfs_client
filename	yfs_client.cc	/^yfs_client::filename(inum inum)$/;"	f	class:yfs_client
first	config.h	/^  std::string first;$/;"	m	class:config
flush	extent_client_cache.cc	/^extent_client_cache::flush(extent_protocol::extentid_t eid)$/;"	f	class:extent_client_cache
force_exit	lock_smain.cc	/^force_exit(int) {$/;"	f	file:
force_exit	lock_tester.cc	/^force_exit(int) {$/;"	f	file:
free_reply_window	rpc/rpc.cc	/^rpcs::free_reply_window(void)$/;"	f	class:rpcs
fuseserver_create	fuse.cc	/^fuseserver_create(fuse_req_t req, fuse_ino_t parent, const char *name,$/;"	f
fuseserver_createhelper	fuse.cc	/^fuseserver_createhelper(fuse_ino_t parent, const char *name,$/;"	f
fuseserver_getattr	fuse.cc	/^fuseserver_getattr(fuse_req_t req, fuse_ino_t ino,$/;"	f
fuseserver_lookup	fuse.cc	/^fuseserver_lookup(fuse_req_t req, fuse_ino_t parent, const char *name)$/;"	f
fuseserver_mkdir	fuse.cc	/^fuseserver_mkdir(fuse_req_t req, fuse_ino_t parent, const char *name,$/;"	f
fuseserver_mknod	fuse.cc	/^void fuseserver_mknod( fuse_req_t req, fuse_ino_t parent, $/;"	f
fuseserver_open	fuse.cc	/^fuseserver_open(fuse_req_t req, fuse_ino_t ino,$/;"	f
fuseserver_oper	fuse.cc	/^struct fuse_lowlevel_ops fuseserver_oper;$/;"	v	typeref:struct:fuse_lowlevel_ops
fuseserver_read	fuse.cc	/^fuseserver_read(fuse_req_t req, fuse_ino_t ino, size_t size,$/;"	f
fuseserver_readdir	fuse.cc	/^fuseserver_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,$/;"	f
fuseserver_setattr	fuse.cc	/^fuseserver_setattr(fuse_req_t req, fuse_ino_t ino, struct stat *attr,$/;"	f
fuseserver_statfs	fuse.cc	/^fuseserver_statfs(fuse_req_t req)$/;"	f
fuseserver_unlink	fuse.cc	/^fuseserver_unlink(fuse_req_t req, fuse_ino_t parent, const char *name)$/;"	f
fuseserver_write	fuse.cc	/^fuseserver_write(fuse_req_t req, fuse_ino_t ino,$/;"	f
get	extent_client.cc	/^extent_client::get(extent_protocol::extentid_t eid, std::string &buf)$/;"	f	class:extent_client
get	extent_client_cache.cc	/^extent_client_cache::get(extent_protocol::extentid_t eid, std::string &buf)$/;"	f	class:extent_client_cache
get	extent_protocol.h	/^    get,$/;"	e	enum:extent_protocol::rpc_numbers
get	extent_server.cc	/^int extent_server::get(extent_protocol::extentid_t id, std::string &buf)$/;"	f	class:extent_server
get_content	rpc/marshall.h	/^		std::string get_content() { $/;"	f	class:marshall
get_handle	handle.cc	/^handle_mgr::get_handle(std::string m)$/;"	f	class:handle_mgr
get_instance_h	paxos.h	/^  unsigned get_instance_h() { return instance_h; };$/;"	f	class:acceptor
get_n_h	paxos.h	/^  prop_t get_n_h() { return n_h; };$/;"	f	class:acceptor
get_num_views	rsm_tester.pl	/^sub get_num_views {$/;"	s
get_refconn	rpc/rpc.cc	/^rpcc::get_refconn(connection **ch)$/;"	f	class:rpcc
get_rpcs	config.h	/^  rpcs *get_rpcs() { return acc->get_rpcs(); }$/;"	f	class:config
get_rpcs	paxos.h	/^  rpcs *get_rpcs() { return pxs; };$/;"	f	class:acceptor
get_view	config.cc	/^config::get_view(unsigned instance)$/;"	f	class:config
get_view_wo	config.cc	/^config::get_view_wo(unsigned instance)$/;"	f	class:config
getattr	extent_client.cc	/^extent_client::getattr(extent_protocol::extentid_t eid, $/;"	f	class:extent_client
getattr	extent_client_cache.cc	/^extent_client_cache::getattr(extent_protocol::extentid_t eid, $/;"	f	class:extent_client_cache
getattr	extent_protocol.h	/^    getattr,$/;"	e	enum:extent_protocol::rpc_numbers
getattr	extent_server.cc	/^int extent_server::getattr(extent_protocol::extentid_t id, extent_protocol::attr &a)$/;"	f	class:extent_server
getattr	fuse.cc	/^getattr(yfs_client::inum inum, struct stat &st)$/;"	f
getdir	yfs_client.cc	/^yfs_client::getdir(inum inum, dirinfo &din)$/;"	f	class:yfs_client
getfile	yfs_client.cc	/^yfs_client::getfile(inum inum, fileinfo &fin)$/;"	f	class:yfs_client
gettime_h	gettime.h	2;"	d
got_pdu	rpc/rpc.cc	/^rpcc::got_pdu(connection *c, char *b, int sz)$/;"	f	class:rpcc
got_pdu	rpc/rpc.cc	/^rpcs::got_pdu(connection *c, char *b, int sz)$/;"	f	class:rpcs
h	handle.h	/^  struct hinfo *h;$/;"	m	class:handle	typeref:struct:handle::hinfo
handin_file	GNUmakefile	/^handin_file=$(shell whoami)-lab$(LAB).tgz$/;"	m
handin_ignore	GNUmakefile	/^handin_ignore=$(clean_files) core* *log$/;"	m
handle	handle.cc	/^handle::handle(std::string m) $/;"	f	class:handle
handle	handle.h	/^class handle {$/;"	c
handle_22	rpc/rpctest.cc	/^srv::handle_22(const std::string a, std::string b, std::string &r)$/;"	f	class:srv
handle_bigrep	rpc/rpctest.cc	/^srv::handle_bigrep(const int len, std::string &r)$/;"	f	class:srv
handle_fast	rpc/rpctest.cc	/^srv::handle_fast(const int a, int &r)$/;"	f	class:srv
handle_h	handle.h	24;"	d
handle_mgr	handle.cc	/^handle_mgr::handle_mgr()$/;"	f	class:handle_mgr
handle_mgr	handle.h	/^class handle_mgr {$/;"	c
handle_mutex	handle.h	/^  pthread_mutex_t handle_mutex;$/;"	m	class:handle_mgr
handle_slow	rpc/rpctest.cc	/^srv::handle_slow(const int a, int &r)$/;"	f	class:srv
handler	rpc/rpc.h	/^		handler() { }$/;"	f	class:handler
handler	rpc/rpc.h	/^class handler {$/;"	c
has_callback	rpc/pollmgr.cc	/^PollMgr::has_callback(int fd, poll_flag flag, aio_callback *c)$/;"	f	class:PollMgr
has_space_c_	rpc/fifo.h	/^		pthread_cond_t has_space_c_; \/\/ q is not longer overfull$/;"	m	class:fifo
heartbeat	config.cc	/^config::heartbeat(std::string m, unsigned vid, int &r)$/;"	f	class:config
heartbeat	paxos_protocol.h	/^    heartbeat,$/;"	e	enum:paxos_protocol::rpc_numbers
heartbeat_cond	config.h	/^  pthread_cond_t heartbeat_cond;$/;"	m	class:config
heartbeat_t	config.h	/^  } heartbeat_t;$/;"	t	class:config	typeref:enum:config::__anon3
heartbeater	config.cc	/^config::heartbeater()$/;"	f	class:config
heartbeatthread	config.cc	/^heartbeatthread(void *x)$/;"	f	file:
hfiles1	GNUmakefile	/^hfiles1=rpc\/fifo.h rpc\/connection.h rpc\/rpc.h rpc\/marshall.h rpc\/method_thread.h\\$/;"	m
hfiles2	GNUmakefile	/^hfiles2=yfs_client.h extent_client.h extent_protocol.h extent_server.h$/;"	m
hfiles3	GNUmakefile	/^hfiles3=lock_client_cache.h lock_server_cache.h handle.h tprintf.h$/;"	m
hfiles4	GNUmakefile	/^hfiles4=log.h rsm.h rsm_protocol.h config.h paxos.h paxos_protocol.h rsm_state_transfer.h rsmtest_client.h tprintf.h$/;"	m
hfiles5	GNUmakefile	/^hfiles5=rsm_state_transfer.h rsm_client.h$/;"	m
highfds_	rpc/pollmgr.h	/^		int highfds_;$/;"	m	class:SelectAIO
hinfo	handle.h	/^struct hinfo {$/;"	s
hmap	handle.h	/^  std::map<std::string, struct hinfo *> hmap;$/;"	m	class:handle_mgr
hostname	lock_client_cache.h	/^  std::string hostname;$/;"	m	class:lock_client_cache
hostname	lock_client_cache_rsm.h	/^  std::string hostname;$/;"	m	class:lock_client_cache_rsm
huge	test-lab-3-b.c	/^char huge[65536*2+1];$/;"	v
id	fuse.cc	/^int id() { $/;"	f
id	lock_client_cache.h	/^  std::string id;$/;"	m	class:lock_client_cache
id	lock_client_cache_rsm.h	/^  std::string id;$/;"	m	class:lock_client_cache_rsm
id	rpc/rpc.h	/^		unsigned int id() { return clt_nonce_; }$/;"	f	class:rpcc
incref	rpc/connection.cc	/^connection::incref()$/;"	f	class:connection
ind	rpc/marshall.h	/^		int ind() { return _ind;}$/;"	f	class:unmarshall
init_members	rsm_client.cc	/^rsm_client::init_members()$/;"	f	class:rsm_client
instance	paxos.h	/^  unsigned instance() { return instance_h; }$/;"	f	class:acceptor
instance	paxos_protocol.h	/^    unsigned instance;$/;"	m	struct:paxos_protocol::acceptarg
instance	paxos_protocol.h	/^    unsigned instance;$/;"	m	struct:paxos_protocol::decidearg
instance	paxos_protocol.h	/^    unsigned instance;$/;"	m	struct:paxos_protocol::preparearg
instance	rpc/pollmgr.cc	/^PollMgr *PollMgr::instance = NULL;$/;"	m	class:PollMgr	file:
instance	rpc/pollmgr.h	/^		static PollMgr *instance;$/;"	m	class:PollMgr
instance_h	paxos.h	/^  unsigned instance_h;	\/\/ number of the highest instance we have decided$/;"	m	class:acceptor
insync	rsm.h	/^  bool insync; $/;"	m	class:rsm
intret	rpc/rpc.h	/^			int intret;$/;"	m	struct:rpcc::caller
inum	yfs_client.h	/^    yfs_client::inum inum;$/;"	m	struct:yfs_client::dirent
inum	yfs_client.h	/^  typedef unsigned long long inum;$/;"	t	class:yfs_client
inviewchange	rsm.h	/^  bool inviewchange;$/;"	m	class:rsm
invoke	rsm.cc	/^rsm::invoke(int proc, viewstamp vs, std::string req, int &dummy)$/;"	f	class:rsm
invoke	rsm_client.cc	/^rsm_client::invoke(int proc, std::string req, std::string &rep)$/;"	f	class:rsm_client
invoke	rsm_protocol.h	/^    invoke = 0x10001,$/;"	e	enum:rsm_protocol::rpc_numbers
invoke	rsm_protocol.h	/^    invoke = 0x9001,$/;"	e	enum:rsm_client_protocol::rpc_numbers
invoke_mutex	rsm.h	/^  pthread_mutex_t invoke_mutex;$/;"	m	class:rsm
is_watched	rpc/pollmgr.cc	/^EPollAIO::is_watched(int fd, poll_flag flag)$/;"	f	class:EPollAIO
is_watched	rpc/pollmgr.cc	/^SelectAIO::is_watched(int fd, poll_flag flag)$/;"	f	class:SelectAIO
isamember	paxos.cc	/^bool isamember(std::string m, const std::vector<std::string> &nodes)$/;"	f
isdead	rpc/connection.cc	/^connection::isdead()$/;"	f	class:connection
isdir	yfs_client.cc	/^yfs_client::isdir(inum inum)$/;"	f	class:yfs_client
isfile	yfs_client.cc	/^yfs_client::isfile(inum inum)$/;"	f	class:yfs_client
islossy	rpc/rpc.h	/^                int islossy() { return lossytest_ > 0; }$/;"	f	class:rpcc
ismember	config.cc	/^config::ismember(std::string m, unsigned vid)$/;"	f	class:config
isrunning	paxos.cc	/^proposer::isrunning()$/;"	f	class:proposer
isvalid	rpc/rpc.h	/^                    bool isvalid() { return xid != -1; }$/;"	f	struct:rpcc::request
job_t	rpc/thr_pool.h	/^		struct job_t {$/;"	s	class:ThrPool
jobq_	rpc/thr_pool.h	/^		fifo<job_t> jobq_;$/;"	m	class:ThrPool
join	rsm.cc	/^rsm::join(std::string m) {$/;"	f	class:rsm
joinreq	rsm.cc	/^rsm::joinreq(std::string m, viewstamp last, rsm_protocol::joinres &r)$/;"	f	class:rsm
joinreq	rsm_protocol.h	/^    joinreq,$/;"	e	enum:rsm_protocol::rpc_numbers
joinres	rsm_protocol.h	/^  struct joinres {$/;"	s	class:rsm_protocol
jsl_log	rpc/jsl_log.h	14;"	d
jsl_set_debug	rpc/jsl_log.cc	/^jsl_set_debug(int level) {$/;"	f
killprocess	rsm_tester.pl	/^sub killprocess {$/;"	s
known_mems	rsm_client.h	/^  std::vector<std::string> known_mems;$/;"	m	class:rsm_client
l	paxos.h	/^  log *l;$/;"	m	class:acceptor
l	paxos.h	/^  log *l;$/;"	m	class:proposer
labdir	GNUmakefile	/^labdir=$(shell basename $(PWD))$/;"	m
last	rsm_protocol.h	/^    viewstamp last;$/;"	m	struct:rsm_protocol::transferres
last_myvs	rsm.h	/^  viewstamp last_myvs;   \/\/ Viewstamp of the last executed request$/;"	m	class:rsm
last_port	lock_client_cache_rsm.cc	/^int lock_client_cache_rsm::last_port = 0;$/;"	m	class:lock_client_cache_rsm	file:
last_port	lock_client_cache_rsm.h	/^  static int last_port;$/;"	m	class:lock_client_cache_rsm
lc	lock_demo.cc	/^lock_client *lc;$/;"	v
lc	lock_tester.cc	/^lock_client_cache_rsm **lc = new lock_client_cache_rsm * [nt];$/;"	v
lc	yfs_client.h	/^  lock_client *lc;$/;"	m	class:yfs_client
lc_	yfs_client.h	/^		lock_client *lc_;$/;"	m	class:ScopedLockClient
lcond	lock_protocol.h	/^	pthread_cond_t lcond;$/;"	m	class:lock
lid	lock_protocol.h	/^	lock_protocol::lockid_t lid;$/;"	m	class:lock
lid	yfs_client.h	/^		lock_protocol::lockid_t lid;$/;"	m	class:ScopedLockClient
listener_	rpc/rpc.h	/^	tcpsconn* listener_;$/;"	m	class:rpcs
livecheck	test-lab-2-a.pl	/^sub livecheck {$/;"	s
livecheck	test-lab-3-a.pl	/^sub livecheck {$/;"	s
lock	lock_protocol.h	/^class lock {$/;"	c
lock	lock_server.cc	/^lock::lock(lock_protocol::lockid_t lid):$/;"	f	class:lock
lock	lock_server.cc	/^lock::lock(lock_protocol::lockid_t lid, int stat):$/;"	f	class:lock
lock_client	lock_client.cc	/^lock_client::lock_client(std::string dst)$/;"	f	class:lock_client
lock_client	lock_client.h	/^class lock_client {$/;"	c
lock_client_cache	lock_client_cache.cc	/^lock_client_cache::lock_client_cache(std::string xdst, $/;"	f	class:lock_client_cache
lock_client_cache	lock_client_cache.h	/^class lock_client_cache : public lock_client {$/;"	c
lock_client_cache_h	lock_client_cache.h	5;"	d
lock_client_cache_rsm	lock_client_cache_rsm.cc	/^lock_client_cache_rsm::lock_client_cache_rsm(std::string xdst, $/;"	f	class:lock_client_cache_rsm
lock_client_cache_rsm	lock_client_cache_rsm.h	/^class lock_client_cache_rsm : public lock_client {$/;"	c
lock_client_cache_rsm_h	lock_client_cache_rsm.h	5;"	d
lock_client_h	lock_client.h	4;"	d
lock_demo	GNUmakefile	/^lock_demo=lock_demo.cc lock_client.cc$/;"	m
lock_entry	lock_client_cache.h	/^		lock_entry():revoked(false), retry(false), state(NONE) {$/;"	f	struct:lock_client_cache::lock_entry
lock_entry	lock_client_cache.h	/^	struct lock_entry {$/;"	s	class:lock_client_cache
lock_entry	lock_server_cache.h	/^		lock_entry():revoked(false),state(FREE) {}$/;"	f	struct:lock_server_cache::lock_entry
lock_entry	lock_server_cache.h	/^	struct lock_entry {$/;"	s	class:lock_server_cache
lock_protocol	lock_protocol.h	/^class lock_protocol {$/;"	c
lock_protocol_h	lock_protocol.h	4;"	d
lock_release_user	lock_client_cache.h	/^class lock_release_user {$/;"	c
lock_release_user	lock_client_cache_rsm.h	/^class lock_release_user {$/;"	c
lock_server	GNUmakefile	/^lock_server=lock_server.cc lock_smain.cc$/;"	m
lock_server	lock_server.cc	/^lock_server::lock_server():$/;"	f	class:lock_server
lock_server	lock_server.h	/^class lock_server {$/;"	c
lock_server_cache	lock_server_cache.cc	/^lock_server_cache::lock_server_cache()$/;"	f	class:lock_server_cache
lock_server_cache	lock_server_cache.h	/^class lock_server_cache {$/;"	c
lock_server_cache_h	lock_server_cache.h	2;"	d
lock_server_cache_rsm	lock_server_cache_rsm.cc	/^lock_server_cache_rsm::lock_server_cache_rsm(class rsm *_rsm) $/;"	f	class:lock_server_cache_rsm
lock_server_cache_rsm	lock_server_cache_rsm.h	/^class lock_server_cache_rsm : public rsm_state_transfer {$/;"	c
lock_server_cache_rsm_h	lock_server_cache_rsm.h	2;"	d
lock_server_h	lock_server.h	5;"	d
lock_state	lock_client_cache.h	/^	enum lock_state {NONE, FREE, LOCKED, ACQUIRING, RELEASING};$/;"	g	class:lock_client_cache
lock_state	lock_server_cache.h	/^	enum lock_state {FREE, LOCKED, LOCKED_AND_WAIT, RETRYING};$/;"	g	class:lock_server_cache
lock_status	lock_protocol.h	/^    enum lock_status {FREE, LOCKED};$/;"	g	class:lock
lock_tester	GNUmakefile	/^lock_tester=lock_tester.cc lock_client.cc$/;"	m
lock_user	yfs_client.h	/^		lock_user(extent_client_cache *e) : ec(e) {}; $/;"	f	class:lock_user
lock_user	yfs_client.h	/^class lock_user : public lock_release_user {$/;"	c
lockid_t	lock_protocol.h	/^  typedef unsigned long long lockid_t;$/;"	t	class:lock_protocol
lockmap	lock_client_cache.h	/^	std::map<lock_protocol::lockid_t, lock_entry> lockmap;$/;"	m	class:lock_client_cache
lockmap	lock_server.h	/^  std::map<lock_protocol::lockid_t, lock* > lockmap;$/;"	m	class:lock_server
lockmap	lock_server_cache.h	/^  std::map<lock_protocol::lockid_t, lock_entry> lockmap;$/;"	m	class:lock_server_cache
log	log.cc	/^log::log(acceptor *_acc, std::string _me)$/;"	f	class:log
log	log.h	/^class log {$/;"	c
log	rsm_protocol.h	/^    std::string log;$/;"	m	struct:rsm_protocol::joinres
log_h	log.h	2;"	d
logaccept	log.cc	/^log::logaccept(prop_t n, std::string v)$/;"	f	class:log
loginstance	log.cc	/^log::loginstance(unsigned instance, std::string v)$/;"	f	class:log
logprop	log.cc	/^log::logprop(prop_t n_h)$/;"	f	class:log
logread	log.cc	/^log::logread(void)$/;"	f	class:log
lookup	yfs_client.cc	/^yfs_client::lookup(inum parent, const char *name, inum &inum, bool *found) $/;"	f	class:yfs_client
lossy	rpc/connection.h	/^	int lossy;$/;"	m	struct:bundle
lossy_	rpc/connection.h	/^		const int lossy_;$/;"	m	class:connection
lossy_	rpc/connection.h	/^		int lossy_;$/;"	m	class:tcpsconn
lossy_test	rpc/rpctest.cc	/^lossy_test()$/;"	f
lossytest_	rpc/rpc.h	/^		int lossytest_;$/;"	m	class:rpcc
lossytest_	rpc/rpc.h	/^	int lossytest_; $/;"	m	class:rpcs
lu	lock_client_cache.h	/^  class lock_release_user *lu;$/;"	m	class:lock_client_cache	typeref:class:lock_client_cache::lock_release_user
lu	lock_client_cache_rsm.h	/^  class lock_release_user *lu;$/;"	m	class:lock_client_cache_rsm	typeref:class:lock_client_cache_rsm::lock_release_user
m	handle.h	/^  std::string m;$/;"	m	struct:hinfo
m	paxos_protocol.h	/^  std::string m;$/;"	m	struct:prop_t
m	rpc/method_thread.h	/^				void (C::*m)(A1 a1, A2 a2);$/;"	m	class:__anon4::XXX
m	rpc/rpc.h	/^			pthread_mutex_t m;$/;"	m	struct:rpcc::caller
m_	rpc/connection.h	/^		pthread_mutex_t m_;$/;"	m	class:connection
m_	rpc/connection.h	/^		pthread_mutex_t m_;$/;"	m	class:tcpsconn
m_	rpc/fifo.h	/^		pthread_mutex_t m_;$/;"	m	class:fifo
m_	rpc/pollmgr.h	/^		pthread_mutex_t m_;$/;"	m	class:PollMgr
m_	rpc/pollmgr.h	/^		pthread_mutex_t m_;$/;"	m	class:SelectAIO
m_	rpc/rpc.h	/^		pthread_mutex_t m_; \/\/ protect insert\/delete to calls[]$/;"	m	class:rpcc
m_	rpc/slock.h	/^		pthread_mutex_t *m_;$/;"	m	struct:ScopedLock
main	extent_smain.cc	/^main(int argc, char *argv[])$/;"	f
main	fuse.cc	/^main(int argc, char *argv[])$/;"	f
main	lock_demo.cc	/^main(int argc, char *argv[])$/;"	f
main	lock_smain.cc	/^main(int argc, char *argv[])$/;"	f
main	lock_tester.cc	/^main(int argc, char *argv[])$/;"	f
main	rpc/rpctest.cc	/^main(int argc, char *argv[])$/;"	f
main	rsm_tester.cc	/^main(int argc, char *argv[])$/;"	f
main	test-lab-3-b.c	/^main(int argc, char *argv[])$/;"	f
main	test-lab-3-c.c	/^main(int argc, char *argv[])$/;"	f
majority	paxos.cc	/^proposer::majority(const std::vector<std::string> &l1, $/;"	f	class:proposer
make_sockaddr	rpc/rpc.cc	/^make_sockaddr(const char *host, const char *port, struct sockaddr_in *dst){$/;"	f
make_sockaddr	rpc/rpc.cc	/^make_sockaddr(const char *hostandport, struct sockaddr_in *dst){$/;"	f
marshal_state	lock_server_cache_rsm.cc	/^lock_server_cache_rsm::marshal_state()$/;"	f	class:lock_server_cache_rsm
marshall	rpc/marshall.h	/^		marshall() {$/;"	f	class:marshall
marshall	rpc/marshall.h	/^class marshall {$/;"	c
marshall_h	rpc/marshall.h	2;"	d
max_	rpc/fifo.h	/^		unsigned int max_; \/\/maximum capacity of the queue, block enq threads if exceeds this limit$/;"	m	class:fifo
me	config.h	/^  std::string me;$/;"	m	class:config
me	paxos.h	/^  std::string me;$/;"	m	class:acceptor
me	paxos.h	/^  std::string me;$/;"	m	class:proposer
members	config.cc	/^config::members(std::string value)$/;"	f	class:config
members	rsm_protocol.h	/^    members,$/;"	e	enum:rsm_client_protocol::rpc_numbers
mems	config.h	/^  std::vector<std::string> mems;$/;"	m	class:config
method_thread	rpc/method_thread.h	/^method_thread(C *o, bool detach, void (C::*m)())$/;"	f
method_thread	rpc/method_thread.h	/^method_thread(C *o, bool detach, void (C::*m)(A), A a)$/;"	f
method_thread	rpc/method_thread.h	/^method_thread(C *o, bool detach, void (C::*m)(A1 , A2 ), A1 a1, A2 a2)$/;"	f
method_thread	rpc/method_thread.h	/^method_thread(C *o, bool detach, void (C::*m)(A1 , A2, A3 ), A1 a1, A2 a2, A3 a3)$/;"	f
method_thread_child	rpc/method_thread.h	/^method_thread_child()$/;"	f
method_thread_h	rpc/method_thread.h	2;"	d
method_thread_parent	rpc/method_thread.h	/^method_thread_parent(void *(*fn)(void *), void *arg, bool detach)$/;"	f
mgr	handle.cc	/^handle_mgr mgr;$/;"	v
mgr	rpc/connection.h	/^	chanmgr *mgr;$/;"	m	struct:bundle
mgr_	rpc/connection.h	/^		chanmgr *mgr_;$/;"	m	class:connection
mgr_	rpc/connection.h	/^		chanmgr *mgr_;$/;"	m	class:tcpsconn
min	fuse.cc	341;"	d	file:
mkdir	yfs_client.cc	/^yfs_client::mkdir(inum parent, const char *name, mode_t mode, inum &inum)$/;"	f	class:yfs_client
mtime	extent_protocol.h	/^    unsigned int mtime;$/;"	m	struct:extent_protocol::attr
mtime	yfs_client.h	/^    unsigned long mtime;$/;"	m	struct:yfs_client::dirinfo
mtime	yfs_client.h	/^    unsigned long mtime;$/;"	m	struct:yfs_client::fileinfo
mutex	extent_server.h	/^  pthread_mutex_t mutex;$/;"	m	class:extent_server
mutex	lock_server.h	/^  pthread_mutex_t mutex;$/;"	m	class:lock_server
my_n	paxos.h	/^  prop_t my_n;		\/\/ number of the last proposal used in this instance$/;"	m	class:proposer
myaddr	config.h	/^  std::string myaddr() { return me; };$/;"	f	class:config
mydie	rsm_tester.pl	/^sub mydie {$/;"	s
myid	fuse.cc	/^int myid;$/;"	v
myvid	config.h	/^  unsigned myvid;$/;"	m	class:config
myvs	rsm.h	/^  viewstamp myvs;$/;"	m	class:rsm
n	paxos_protocol.h	/^    prop_t n;$/;"	m	struct:paxos_protocol::acceptarg
n	paxos_protocol.h	/^    prop_t n;$/;"	m	struct:paxos_protocol::preparearg
n	paxos_protocol.h	/^  unsigned n;$/;"	m	struct:prop_t
n2i	yfs_client.cc	/^yfs_client::n2i(std::string n)$/;"	f	class:yfs_client
n_a	paxos.h	/^  prop_t n_a;		\/\/ number of highest proposal accepted$/;"	m	class:acceptor
n_a	paxos_protocol.h	/^    prop_t n_a;$/;"	m	struct:paxos_protocol::prepareres
n_h	paxos.h	/^  prop_t n_h;		\/\/ number of the highest proposal seen in a prepare$/;"	m	class:acceptor
nacquire	lock_server.h	/^  int nacquire;$/;"	m	class:lock_server
nacquire	lock_server_cache.h	/^  int nacquire;$/;"	m	class:lock_server_cache
nacquire	lock_server_cache_rsm.h	/^  int nacquire;$/;"	m	class:lock_server_cache_rsm
name	log.h	/^  std::string name;$/;"	m	class:log
name	yfs_client.h	/^    std::string name;$/;"	m	struct:yfs_client::dirent
net_repair	rsm_protocol.h	/^    net_repair = 0x12001,$/;"	e	enum:rsm_test_protocol::rpc_numbers
net_repair	rsmtest_client.cc	/^rsmtest_client::net_repair(int heal)$/;"	f	class:rsmtest_client
net_repair_wo	rsm.cc	/^rsm::net_repair_wo(bool heal)$/;"	f	class:rsm
non_empty_c_	rpc/fifo.h	/^		pthread_cond_t non_empty_c_; \/\/ q went non-empty$/;"	m	class:fifo
nonce_	rpc/rpc.h	/^	unsigned int nonce_;$/;"	m	class:rpcs
nt	lock_tester.cc	/^int nt = 6; \/\/XXX: lab1's rpc handlers are blocking. Since rpcs uses a thread pool of 10 threads, we cannot test more than 10 blocking rpc.$/;"	v
nthreads_	rpc/thr_pool.h	/^		int nthreads_;$/;"	m	class:ThrPool
o	rpc/method_thread.h	/^				C *o;$/;"	m	class:__anon4::XXX
ok	rpc/marshall.h	/^		bool ok() { return _ok; }$/;"	f	class:unmarshall
okdone	rpc/rpc.cc	/^unmarshall::okdone()$/;"	f	class:unmarshall
oldinstance	paxos_protocol.h	/^    bool oldinstance;$/;"	m	struct:paxos_protocol::prepareres
oldsrv_failure	rpc/rpc.h	/^		static const int oldsrv_failure = -5;$/;"	m	class:rpc_const
oops	test-lab-3-a.pl	/^sub oops {$/;"	s
oops1	test-lab-3-a.pl	/^sub oops1 {$/;"	s
operator !=	rsm_protocol.h	/^inline bool operator!=(viewstamp a, viewstamp b) {$/;"	f
operator <	rpc/rpc.cc	/^bool operator<(const sockaddr_in &a, const sockaddr_in &b){$/;"	f
operator <<	extent_protocol.h	/^operator<<(marshall &m, extent_protocol::attr a)$/;"	f
operator <<	paxos_protocol.h	/^operator<<(marshall &m, paxos_protocol::acceptarg a)$/;"	f
operator <<	paxos_protocol.h	/^operator<<(marshall &m, paxos_protocol::decidearg a)$/;"	f
operator <<	paxos_protocol.h	/^operator<<(marshall &m, paxos_protocol::preparearg a)$/;"	f
operator <<	paxos_protocol.h	/^operator<<(marshall &m, paxos_protocol::prepareres r)$/;"	f
operator <<	paxos_protocol.h	/^operator<<(marshall &m, prop_t a)$/;"	f
operator <<	rpc/marshall.h	/^operator<<(marshall &m, const std::map<A,B> &d) {$/;"	f
operator <<	rpc/marshall.h	/^operator<<(marshall &m, std::vector<C> v)$/;"	f
operator <<	rpc/rpc.cc	/^operator<<(marshall &m, bool x)$/;"	f
operator <<	rpc/rpc.cc	/^operator<<(marshall &m, char x)$/;"	f
operator <<	rpc/rpc.cc	/^operator<<(marshall &m, const std::string &s)$/;"	f
operator <<	rpc/rpc.cc	/^operator<<(marshall &m, int x)$/;"	f
operator <<	rpc/rpc.cc	/^operator<<(marshall &m, short x)$/;"	f
operator <<	rpc/rpc.cc	/^operator<<(marshall &m, unsigned char x)$/;"	f
operator <<	rpc/rpc.cc	/^operator<<(marshall &m, unsigned int x)$/;"	f
operator <<	rpc/rpc.cc	/^operator<<(marshall &m, unsigned long long x)$/;"	f
operator <<	rpc/rpc.cc	/^operator<<(marshall &m, unsigned short x)$/;"	f
operator <<	rsm_protocol.h	/^inline marshall& operator<<(marshall &m, viewstamp v)$/;"	f
operator <<	rsm_protocol.h	/^operator<<(marshall &m, rsm_protocol::joinres r)$/;"	f
operator <<	rsm_protocol.h	/^operator<<(marshall &m, rsm_protocol::transferres r)$/;"	f
operator ==	rsm_protocol.h	/^inline bool operator==(viewstamp a, viewstamp b) {$/;"	f
operator >	paxos.cc	/^operator> (const prop_t &a, const prop_t &b)$/;"	f
operator >	rsm_protocol.h	/^inline bool operator>(viewstamp a, viewstamp b) {$/;"	f
operator >=	paxos.cc	/^operator>= (const prop_t &a, const prop_t &b)$/;"	f
operator >>	extent_protocol.h	/^operator>>(unmarshall &u, extent_protocol::attr &a)$/;"	f
operator >>	paxos_protocol.h	/^operator>>(unmarshall &u, paxos_protocol::acceptarg &a)$/;"	f
operator >>	paxos_protocol.h	/^operator>>(unmarshall &u, paxos_protocol::decidearg &a)$/;"	f
operator >>	paxos_protocol.h	/^operator>>(unmarshall &u, paxos_protocol::preparearg &a)$/;"	f
operator >>	paxos_protocol.h	/^operator>>(unmarshall &u, paxos_protocol::prepareres &r)$/;"	f
operator >>	paxos_protocol.h	/^operator>>(unmarshall &u, prop_t &a)$/;"	f
operator >>	rpc/marshall.h	/^operator>>(unmarshall &u, std::map<A,B> &d) {$/;"	f
operator >>	rpc/marshall.h	/^operator>>(unmarshall &u, std::vector<C> &v)$/;"	f
operator >>	rpc/rpc.cc	/^operator>>(unmarshall &u, bool &x)$/;"	f
operator >>	rpc/rpc.cc	/^operator>>(unmarshall &u, char &x)$/;"	f
operator >>	rpc/rpc.cc	/^operator>>(unmarshall &u, int &x)$/;"	f
operator >>	rpc/rpc.cc	/^operator>>(unmarshall &u, short &x)$/;"	f
operator >>	rpc/rpc.cc	/^operator>>(unmarshall &u, std::string &s)$/;"	f
operator >>	rpc/rpc.cc	/^operator>>(unmarshall &u, unsigned char &x)$/;"	f
operator >>	rpc/rpc.cc	/^operator>>(unmarshall &u, unsigned int &x)$/;"	f
operator >>	rpc/rpc.cc	/^operator>>(unmarshall &u, unsigned long long &x)$/;"	f
operator >>	rpc/rpc.cc	/^operator>>(unmarshall &u, unsigned short &x)$/;"	f
operator >>	rsm_protocol.h	/^inline unmarshall& operator>>(unmarshall &u, viewstamp &v) {$/;"	f
operator >>	rsm_protocol.h	/^operator>>(unmarshall &u, rsm_protocol::joinres &r)$/;"	f
operator >>	rsm_protocol.h	/^operator>>(unmarshall &u, rsm_protocol::transferres &r)$/;"	f
owner	lock_server_cache.h	/^		std::string owner;$/;"	m	struct:lock_server_cache::lock_entry
p	fuse.cc	/^    char *p;$/;"	m	struct:dirbuf	file:
pack	rpc/rpc.cc	/^marshall::pack(int x)$/;"	f	class:marshall
pack_reply_header	rpc/marshall.h	/^		void pack_reply_header(const reply_header &h) {$/;"	f	class:marshall
pack_req_header	rpc/marshall.h	/^		void pack_req_header(const req_header &h) {$/;"	f	class:marshall
partition1	rsm.cc	/^rsm::partition1()$/;"	f	class:rsm
partitioned	rsm.h	/^  bool partitioned;$/;"	m	class:rsm
paxos_change	paxos.h	/^class paxos_change {$/;"	c
paxos_commit	config.cc	/^config::paxos_commit(unsigned instance, std::string value)$/;"	f	class:config
paxos_h	paxos.h	2;"	d
paxos_log	rsm_tester.pl	/^sub paxos_log {$/;"	s
paxos_protocol	paxos_protocol.h	/^class paxos_protocol {$/;"	c
paxos_protocol_h	paxos_protocol.h	2;"	d
pending_change_	rpc/pollmgr.h	/^		bool pending_change_;$/;"	m	class:PollMgr
pipe_	rpc/connection.h	/^		int pipe_[2];$/;"	m	class:tcpsconn
pipefd_	rpc/pollmgr.h	/^		int pipefd_[2];$/;"	m	class:SelectAIO
poll_flag	rpc/pollmgr.h	/^} poll_flag;$/;"	t	typeref:enum:__anon5
poll_flag_to_event	rpc/pollmgr.cc	/^int poll_flag_to_event(poll_flag flag)$/;"	f	file:
pollfd_	rpc/pollmgr.h	/^		int pollfd_;$/;"	m	class:EPollAIO
pollmgr_h	rpc/pollmgr.h	2;"	d
pollmgr_is_initialized	rpc/pollmgr.cc	/^static pthread_once_t pollmgr_is_initialized = PTHREAD_ONCE_INIT;$/;"	v	file:
port	rpc/connection.h	/^                inline int port() { return port_; }$/;"	f	class:tcpsconn
port	rpc/rpc.h	/^        inline int port() { return listener_->port(); }$/;"	f	class:rpcs
port	rpc/rpctest.cc	/^int port;$/;"	v
port_	rpc/connection.h	/^                int port_;$/;"	m	class:tcpsconn
port_	rpc/rpc.h	/^	int port_;$/;"	m	class:rpcs
prepare	paxos.cc	/^proposer::prepare(unsigned instance, std::vector<std::string> &accepts, $/;"	f	class:proposer
preparearg	paxos_protocol.h	/^  struct preparearg {$/;"	s	class:paxos_protocol
preparereq	paxos.cc	/^acceptor::preparereq(std::string src, paxos_protocol::preparearg a,$/;"	f	class:acceptor
preparereq	paxos_protocol.h	/^    preparereq = 0x11001,$/;"	e	enum:paxos_protocol::rpc_numbers
prepareres	paxos_protocol.h	/^  struct prepareres {$/;"	s	class:paxos_protocol
primary	rsm.h	/^  std::string primary;$/;"	m	class:rsm
primary	rsm_client.h	/^  std::string primary;$/;"	m	class:rsm_client
primary_failure	rsm_client.cc	/^rsm_client::primary_failure()$/;"	f	class:rsm_client
print_config	rsm_tester.pl	/^sub print_config {$/;"	s
print_members	paxos.cc	/^print_members(const std::vector<std::string> &nodes)$/;"	f
pro	config.h	/^  proposer *pro;$/;"	m	class:config
proc	rpc/marshall.h	/^	int proc;$/;"	m	struct:req_header
process_accept	rpc/connection.cc	/^tcpsconn::process_accept()$/;"	f	class:tcpsconn
procs	rsm.h	/^  std::map<int, handler *> procs;$/;"	m	class:rsm
procs_	rpc/rpc.h	/^	std::map<int, handler *> procs_;$/;"	m	class:rpcs
procs_m_	rpc/rpc.h	/^	pthread_mutex_t procs_m_; \/\/ protect insert\/delete to procs[]$/;"	m	class:rpcs
prop_t	paxos_protocol.h	/^struct prop_t {$/;"	s
proposer	paxos.cc	/^proposer::proposer(class paxos_change *_cfg, class acceptor *_acceptor, $/;"	f	class:proposer
proposer	paxos.h	/^class proposer {$/;"	c
put	extent_client.cc	/^extent_client::put(extent_protocol::extentid_t eid, std::string buf)$/;"	f	class:extent_client
put	extent_client_cache.cc	/^extent_client_cache::put(extent_protocol::extentid_t eid, std::string buf)$/;"	f	class:extent_client_cache
put	extent_protocol.h	/^    put = 0x6001,$/;"	e	enum:extent_protocol::rpc_numbers
put	extent_server.cc	/^int extent_server::put(extent_protocol::extentid_t id, std::string buf, int &)$/;"	f	class:extent_server
pxs	log.h	/^  acceptor *pxs;$/;"	m	class:log
pxs	paxos.h	/^  rpcs *pxs;$/;"	m	class:acceptor
pxs_mutex	paxos.h	/^  pthread_mutex_t pxs_mutex;$/;"	m	class:acceptor
pxs_mutex	paxos.h	/^  pthread_mutex_t pxs_mutex;$/;"	m	class:proposer
pxsrpc	config.h	/^  rpcs *pxsrpc;$/;"	m	class:config
q_	rpc/fifo.h	/^		std::list<T> q_;$/;"	m	class:fifo
random_inum	yfs_client.cc	/^yfs_client::random_inum(bool isfile)$/;"	f	class:yfs_client
randports	rsm_tester.pl	/^sub randports {$/;"	s
rawbyte	rpc/rpc.cc	/^marshall::rawbyte(unsigned char x)$/;"	f	class:marshall
rawbyte	rpc/rpc.cc	/^unmarshall::rawbyte()$/;"	f	class:unmarshall
rawbytes	rpc/rpc.cc	/^marshall::rawbytes(const char *p, int n)$/;"	f	class:marshall
rawbytes	rpc/rpc.cc	/^unmarshall::rawbytes(std::string &ss, unsigned int n)$/;"	f	class:unmarshall
reachable_	rpc/rpc.h	/^		bool reachable_;$/;"	m	class:rpcc
reachable_	rpc/rpc.h	/^	bool reachable_;$/;"	m	class:rpcs
read	yfs_client.cc	/^yfs_client::read(inum inum, off_t off, size_t size, std::string &buf)$/;"	f	class:yfs_client
read_cb	rpc/connection.cc	/^connection::read_cb(int s)$/;"	f	class:connection
readdir	yfs_client.cc	/^yfs_client::readdir(inum inum, std::list<dirent> &dirents) $/;"	f	class:yfs_client
readpdu	rpc/connection.cc	/^connection::readpdu()$/;"	f	class:connection
ready_	rpc/pollmgr.h	/^		struct epoll_event ready_[MAX_POLL_FDS];$/;"	m	class:EPollAIO	typeref:struct:EPollAIO::epoll_event
reap	test-lab-3-b.c	/^reap (int pid)$/;"	f
reap	test-lab-3-c.c	/^reap (int pid)$/;"	f
reconstruct	config.cc	/^config::reconstruct()$/;"	f	class:config
recovery	rsm.cc	/^rsm::recovery()$/;"	f	class:rsm
recovery_cond	rsm.h	/^  pthread_cond_t recovery_cond;$/;"	m	class:rsm
recoverythread	rsm.cc	/^recoverythread(void *x)$/;"	f	file:
ref	rpc/connection.cc	/^connection::ref()$/;"	f	class:connection
ref_m_	rpc/connection.h	/^		pthread_mutex_t ref_m_;$/;"	m	class:connection
refcnt	handle.h	/^  int refcnt;$/;"	m	struct:hinfo
refno_	rpc/connection.h	/^		int refno_;$/;"	m	class:connection
reg	rpc/rpc.h	/^rpcs::reg(unsigned int proc, S*sob, int (S::*meth)(const A1 a1, R & r))$/;"	f	class:rpcs
reg	rpc/rpc.h	/^rpcs::reg(unsigned int proc, S*sob, int (S::*meth)(const A1 a1, const A2 a2, $/;"	f	class:rpcs
reg	rsm.h	/^  rsm::reg(int proc, S*sob, int (S::*meth)(const A1 a1, R & r))$/;"	f	class:rsm
reg	rsm.h	/^  rsm::reg(int proc, S*sob, int (S::*meth)(const A1 a1, const A2 a2, $/;"	f	class:rsm
reg	rsm.h	/^  rsm::reg(int proc, S*sob, int (S::*meth)(const A1 a1, const A2 a2, R & r))$/;"	f	class:rsm
reg1	rpc/rpc.cc	/^rpcs::reg1(unsigned int proc, handler *h)$/;"	f	class:rpcs
reg1	rsm.cc	/^rsm::reg1(int proc, handler *h)$/;"	f	class:rsm
release	lock_client.cc	/^lock_client::release(lock_protocol::lockid_t lid)$/;"	f	class:lock_client
release	lock_client_cache.cc	/^lock_client_cache::release(lock_protocol::lockid_t lid)$/;"	f	class:lock_client_cache
release	lock_client_cache_rsm.cc	/^lock_client_cache_rsm::release(lock_protocol::lockid_t lid)$/;"	f	class:lock_client_cache_rsm
release	lock_protocol.h	/^    release,$/;"	e	enum:lock_protocol::rpc_numbers
release	lock_server.cc	/^lock_server::release(int clt, lock_protocol::lockid_t lid, int &r)$/;"	f	class:lock_server
release	lock_server_cache.cc	/^lock_server_cache::release(lock_protocol::lockid_t lid, std::string id, $/;"	f	class:lock_server_cache
release	lock_server_cache_rsm.cc	/^lock_server_cache_rsm::release(lock_protocol::lockid_t lid, std::string id, $/;"	f	class:lock_server_cache_rsm
releasequeue	lock_client_cache.h	/^		pthread_cond_t releasequeue;$/;"	m	struct:lock_client_cache::lock_entry
releaser	lock_client_cache_rsm.cc	/^lock_client_cache_rsm::releaser()$/;"	f	class:lock_client_cache_rsm
releasethread	lock_client_cache_rsm.cc	/^releasethread(void *x)$/;"	f	file:
remove	extent_client.cc	/^extent_client::remove(extent_protocol::extentid_t eid)$/;"	f	class:extent_client
remove	extent_client_cache.cc	/^extent_client_cache::remove(extent_protocol::extentid_t eid)$/;"	f	class:extent_client_cache
remove	extent_protocol.h	/^    remove$/;"	e	enum:extent_protocol::rpc_numbers
remove	extent_server.cc	/^int extent_server::remove(extent_protocol::extentid_t id, int &)$/;"	f	class:extent_server
remove_wo	config.cc	/^config::remove_wo(std::string m)$/;"	f	class:config
reply_buf_limited	fuse.cc	/^int reply_buf_limited(fuse_req_t req, const char *buf, size_t bufsize,$/;"	f
reply_header	rpc/marshall.h	/^	reply_header(int x=0, int r=0): xid(x), ret(r) {}$/;"	f	struct:reply_header
reply_header	rpc/marshall.h	/^struct reply_header {$/;"	s
reply_t	rpc/rpc.h	/^		reply_t (unsigned int _xid) {$/;"	f	struct:rpcs::reply_t
reply_t	rpc/rpc.h	/^	struct reply_t {$/;"	s	class:rpcs
reply_window_	rpc/rpc.h	/^	std::map<unsigned int, std::list<reply_t> > reply_window_;$/;"	m	class:rpcs
reply_window_m_	rpc/rpc.h	/^	pthread_mutex_t reply_window_m_; \/\/ protect reply window et al$/;"	m	class:rpcs
req_header	rpc/marshall.h	/^	req_header(int x=0, int p=0, int c = 0, int s = 0, int xi = 0):$/;"	f	struct:req_header
req_header	rpc/marshall.h	/^struct req_header {$/;"	s
request	rpc/rpc.h	/^                    request() { clear(); }$/;"	f	struct:rpcc::request
request	rpc/rpc.h	/^                struct request {$/;"	s	class:rpcc
restore	config.cc	/^config::restore(std::string s)$/;"	f	class:config
restore	log.cc	/^log::restore(std::string s)$/;"	f	class:log
restore	paxos.cc	/^acceptor::restore(std::string s)$/;"	f	class:acceptor
ret	rpc/marshall.h	/^	int ret;$/;"	m	struct:reply_header
retrans_	rpc/rpc.h	/^		bool retrans_;$/;"	m	class:rpcc
retry	lock_client_cache.h	/^		bool retry;$/;"	m	struct:lock_client_cache::lock_entry
retry	lock_protocol.h	/^    retry = 0x8002$/;"	e	enum:rlock_protocol::rpc_numbers
retry_handler	lock_client_cache.cc	/^lock_client_cache::retry_handler(lock_protocol::lockid_t lid, $/;"	f	class:lock_client_cache
retry_handler	lock_client_cache_rsm.cc	/^lock_client_cache_rsm::retry_handler(lock_protocol::lockid_t lid, $/;"	f	class:lock_client_cache_rsm
retryer	lock_server_cache_rsm.cc	/^lock_server_cache_rsm::retryer()$/;"	f	class:lock_server_cache_rsm
retryqueue	lock_client_cache.h	/^		pthread_cond_t retryqueue;$/;"	m	struct:lock_client_cache::lock_entry
retrythread	lock_server_cache_rsm.cc	/^retrythread(void *x)$/;"	f	file:
revoke	lock_protocol.h	/^    revoke = 0x8001,$/;"	e	enum:rlock_protocol::rpc_numbers
revoke_handler	lock_client_cache.cc	/^lock_client_cache::revoke_handler(lock_protocol::lockid_t lid, $/;"	f	class:lock_client_cache
revoke_handler	lock_client_cache_rsm.cc	/^lock_client_cache_rsm::revoke_handler(lock_protocol::lockid_t lid, $/;"	f	class:lock_client_cache_rsm
revoked	lock_client_cache.h	/^		bool revoked;$/;"	m	struct:lock_client_cache::lock_entry
revoked	lock_server_cache.h	/^		bool revoked;$/;"	m	struct:lock_server_cache::lock_entry
revoker	lock_server_cache_rsm.cc	/^lock_server_cache_rsm::revoker()$/;"	f	class:lock_server_cache_rsm
revokethread	lock_server_cache_rsm.cc	/^revokethread(void *x)$/;"	f	file:
rfds_	rpc/pollmgr.h	/^		fd_set rfds_;$/;"	m	class:SelectAIO
rlock_port	lock_client_cache.h	/^  int rlock_port;$/;"	m	class:lock_client_cache
rlock_port	lock_client_cache_rsm.h	/^  int rlock_port;$/;"	m	class:lock_client_cache_rsm
rlock_protocol	lock_protocol.h	/^class rlock_protocol {$/;"	c
rpc_checksum_t	rpc/marshall.h	/^typedef uint64_t rpc_checksum_t;$/;"	t
rpc_const	rpc/rpc.h	/^class rpc_const {$/;"	c
rpc_h	rpc/rpc.h	2;"	d
rpc_numbers	extent_protocol.h	/^  enum rpc_numbers {$/;"	g	class:extent_protocol
rpc_numbers	lock_protocol.h	/^  enum rpc_numbers {$/;"	g	class:lock_protocol
rpc_numbers	lock_protocol.h	/^  enum rpc_numbers {$/;"	g	class:rlock_protocol
rpc_numbers	paxos_protocol.h	/^  enum rpc_numbers {$/;"	g	class:paxos_protocol
rpc_numbers	rsm_protocol.h	/^  enum rpc_numbers {$/;"	g	class:rsm_client_protocol
rpc_numbers	rsm_protocol.h	/^  enum rpc_numbers {$/;"	g	class:rsm_protocol
rpc_numbers	rsm_protocol.h	/^  enum rpc_numbers {$/;"	g	class:rsm_test_protocol
rpc_sz_t	rpc/marshall.h	/^typedef int rpc_sz_t;$/;"	t
rpcbind	rpc/rpc.cc	/^rpcs::rpcbind(int a, int &r)$/;"	f	class:rpcs
rpcc	rpc/rpc.cc	/^rpcc::rpcc(sockaddr_in d, bool retrans) : $/;"	f	class:rpcc
rpcc	rpc/rpc.h	/^class rpcc : public chanmgr {$/;"	c
rpclib	GNUmakefile	/^rpclib=rpc\/rpc.cc rpc\/connection.cc rpc\/pollmgr.cc rpc\/thr_pool.cc rpc\/jsl_log.cc gettime.cc$/;"	m
rpcs	rpc/rpc.cc	/^rpcs::rpcs(unsigned int p1, int count)$/;"	f	class:rpcs
rpcs	rpc/rpc.h	/^class rpcs : public chanmgr {$/;"	c
rpcstate_t	rpc/rpc.h	/^	} rpcstate_t;$/;"	t	class:rpcs	typeref:enum:rpcs::__anon6
rpctest	GNUmakefile	/^rpc\/rpctest=rpc\/rpctest.cc$/;"	m
rpdu_	rpc/connection.h	/^		charbuf rpdu_;$/;"	m	class:connection
rsm	lock_server_cache_rsm.h	/^  class rsm *rsm;$/;"	m	class:lock_server_cache_rsm	typeref:class:lock_server_cache_rsm::rsm
rsm	rsm.cc	/^rsm::rsm(std::string _first, std::string _me) $/;"	f	class:rsm
rsm	rsm.h	/^class rsm : public config_view_change {$/;"	c
rsm_client	rsm_client.cc	/^rsm_client::rsm_client(std::string dst)$/;"	f	class:rsm_client
rsm_client	rsm_client.h	/^class rsm_client {$/;"	c
rsm_client_h	rsm_client.h	2;"	d
rsm_client_mutex	rsm_client.h	/^  pthread_mutex_t rsm_client_mutex;$/;"	m	class:rsm_client
rsm_client_protocol	rsm_protocol.h	/^class rsm_client_protocol {$/;"	c
rsm_files	GNUmakefile	/^rsm_files = rsm.cc paxos.cc config.cc log.cc handle.cc$/;"	m
rsm_h	rsm.h	4;"	d
rsm_mutex	rsm.h	/^  pthread_mutex_t rsm_mutex;$/;"	m	class:rsm
rsm_protocol	rsm_protocol.h	/^class rsm_protocol {$/;"	c
rsm_protocol_h	rsm_protocol.h	2;"	d
rsm_state_transfer	rsm_state_transfer.h	/^class rsm_state_transfer {$/;"	c
rsm_state_transfer_h	rsm_state_transfer.h	2;"	d
rsm_test_protocol	rsm_protocol.h	/^class rsm_test_protocol {$/;"	c
rsm_tester	GNUmakefile	/^rsm_tester=rsm_tester.cc rsmtest_client.cc$/;"	m
rsmc	lock_client_cache_rsm.h	/^  rsm_client *rsmc;$/;"	m	class:lock_client_cache_rsm
rsmrpc	rsm.h	/^  rpcs *rsmrpc;$/;"	m	class:rsm
rsmtest_client	rsmtest_client.cc	/^rsmtest_client::rsmtest_client(std::string dst)$/;"	f	class:rsmtest_client
rsmtest_client	rsmtest_client.h	/^class rsmtest_client {$/;"	c
rsmtest_client_h	rsmtest_client.h	4;"	d
run	paxos.cc	/^proposer::run(int instance, std::vector<std::string> cur_nodes, std::string newv)$/;"	f	class:proposer
safebind	handle.cc	/^handle::safebind()$/;"	f	class:handle
send	rpc/connection.cc	/^connection::send(char *b, int sz)$/;"	f	class:connection
send_complete_	rpc/connection.h	/^		pthread_cond_t send_complete_;$/;"	m	class:connection
send_wait_	rpc/connection.h	/^		pthread_cond_t send_wait_;$/;"	m	class:connection
seqno	rsm_protocol.h	/^  unsigned int seqno;$/;"	m	struct:viewstamp
server	rpc/rpctest.cc	/^rpcs *server;  \/\/ server rpc object$/;"	v
server_mutex	lock_server_cache.h	/^  pthread_mutex_t server_mutex;$/;"	m	class:lock_server_cache
service	rpc/rpctest.cc	/^srv service;$/;"	v
set_primary	rsm.cc	/^rsm::set_primary(unsigned vid)$/;"	f	class:rsm
set_rand_seed	rpc/rpc.cc	/^void set_rand_seed()$/;"	f
set_reachable	rpc/rpc.h	/^		void set_reachable(bool r) { reachable_ = r; }$/;"	f	class:rpcc
set_reachable	rpc/rpc.h	/^	void set_reachable(bool r) { reachable_ = r; }$/;"	f	class:rpcs
set_state_transfer	rsm.h	/^  void set_state_transfer(rsm_state_transfer *_stf) { stf = _stf; };$/;"	f	class:rsm
setattr	yfs_client.cc	/^yfs_client::setattr(inum inum, struct stat *attr)$/;"	f	class:yfs_client
setn	paxos.cc	/^proposer::setn()$/;"	f	class:proposer
simple_tests	rpc/rpctest.cc	/^simple_tests(rpcc *c)$/;"	f
size	extent_protocol.h	/^    unsigned int size;$/;"	m	struct:extent_protocol::attr
size	fuse.cc	/^    size_t size;$/;"	m	struct:dirbuf	file:
size	rpc/fifo.h	/^fifo<T>::size()$/;"	f	class:fifo
size	rpc/marshall.h	/^		int size() { return _ind;}$/;"	f	class:marshall
size	rpc/marshall.h	/^		int size() { return _sz;}$/;"	f	class:unmarshall
size	yfs_client.h	/^    unsigned long long size;$/;"	m	struct:yfs_client::fileinfo
solong	rpc/connection.h	/^			int solong; \/\/amount of bytes written or read so far$/;"	m	struct:connection::charbuf
spawn	rsm_tester.pl	/^sub spawn {$/;"	s
spawn_config	rsm_tester.pl	/^sub spawn_config {$/;"	s
spawn_ls	rsm_tester.pl	/^sub spawn_ls {$/;"	s
srv	rpc/rpctest.cc	/^class srv {$/;"	c	file:
srv_nonce	rpc/marshall.h	/^	unsigned int srv_nonce;$/;"	m	struct:req_header
srv_nonce_	rpc/rpc.h	/^		unsigned int srv_nonce_;$/;"	m	class:rpcc
stable	paxos.h	/^  bool stable;$/;"	m	class:proposer
start_nodes	rsm_tester.pl	/^sub start_nodes ($$){$/;"	s
startserver	rpc/rpctest.cc	/^void startserver()$/;"	f
stat	lock_client.cc	/^lock_client::stat(lock_protocol::lockid_t lid)$/;"	f	class:lock_client
stat	lock_protocol.h	/^    stat$/;"	e	enum:lock_protocol::rpc_numbers
stat	lock_server.cc	/^lock_server::stat(int clt, lock_protocol::lockid_t lid, int &r)$/;"	f	class:lock_server
stat	lock_server_cache.cc	/^lock_server_cache::stat(lock_protocol::lockid_t lid, int &r)$/;"	f	class:lock_server_cache
stat	lock_server_cache_rsm.cc	/^lock_server_cache_rsm::stat(lock_protocol::lockid_t lid, int &r)$/;"	f	class:lock_server_cache_rsm
state	lock_client_cache.h	/^		lock_state state;$/;"	m	struct:lock_client_cache::lock_entry
state	lock_server_cache.h	/^		lock_state state;$/;"	m	struct:lock_server_cache::lock_entry
state	rsm_protocol.h	/^    std::string state;$/;"	m	struct:rsm_protocol::transferres
statetransfer	rsm.cc	/^rsm::statetransfer(std::string m)$/;"	f	class:rsm
statetransferdone	rsm.cc	/^rsm::statetransferdone(std::string m) {$/;"	f	class:rsm
static_max	lang/algorithm.h	/^struct static_max$/;"	s
static_min	lang/algorithm.h	/^struct static_min$/;"	s
status	extent_client.h	/^		file_state status;$/;"	m	struct:extent_client_cache::extent
status	extent_protocol.h	/^  typedef int status;$/;"	t	class:extent_protocol
status	lock_protocol.h	/^	int status;$/;"	m	class:lock
status	lock_protocol.h	/^  typedef int status;$/;"	t	class:lock_protocol
status	lock_protocol.h	/^  typedef int status;$/;"	t	class:rlock_protocol
status	paxos_protocol.h	/^  typedef int status;$/;"	t	class:paxos_protocol
status	rsm_protocol.h	/^  typedef int status;$/;"	t	class:rsm_client_protocol
status	rsm_protocol.h	/^  typedef int status;$/;"	t	class:rsm_protocol
status	rsm_protocol.h	/^  typedef int status;$/;"	t	class:rsm_test_protocol
status	yfs_client.h	/^  typedef int status;$/;"	t	class:yfs_client
stf	rsm.h	/^  class rsm_state_transfer *stf;$/;"	m	class:rsm	typeref:class:rsm::rsm_state_transfer
str	rpc/marshall.h	/^		std::string str() {$/;"	f	class:marshall
sync_cond	rsm.h	/^  pthread_cond_t sync_cond;$/;"	m	class:rsm
sync_with_backups	rsm.cc	/^rsm::sync_with_backups()$/;"	f	class:rsm
sync_with_primary	rsm.cc	/^rsm::sync_with_primary()$/;"	f	class:rsm
sz	rpc/connection.h	/^			int sz;$/;"	m	struct:connection::charbuf
sz	rpc/rpc.h	/^		int sz;         \/\/ the size of reply buffer$/;"	m	struct:rpcs::reply_t
sz	rpc/rpc.h	/^		int sz;$/;"	m	struct:rpcs::djob_t
takeJob	rpc/thr_pool.cc	/^ThrPool::takeJob(job_t *j)$/;"	f	class:ThrPool
take_buf	rpc/marshall.h	/^		void take_buf(char **b, int *s) {$/;"	f	class:marshall
take_buf	rpc/marshall.h	/^		void take_buf(char **b, int *sz) {$/;"	f	class:unmarshall
take_content	rpc/marshall.h	/^		void take_content(const std::string &s) {$/;"	f	class:unmarshall
take_in	rpc/rpc.cc	/^unmarshall::take_in(unmarshall &another)$/;"	f	class:unmarshall
tcp	rpc/connection.h	/^	int tcp;$/;"	m	struct:bundle
tcp_	rpc/connection.h	/^		int tcp_; \/\/file desciptor for accepting connection$/;"	m	class:tcpsconn
tcpsconn	rpc/connection.cc	/^tcpsconn::tcpsconn(chanmgr *m1, int port, int lossytest) $/;"	f	class:tcpsconn
tcpsconn	rpc/connection.h	/^class tcpsconn {$/;"	c
test-lab-3-b	GNUmakefile	/^test-lab-3-b=test-lab-3-b.c$/;"	m
test-lab-3-c	GNUmakefile	/^test-lab-3-c=test-lab-3-c.c$/;"	m
test1	lock_tester.cc	/^test1(void)$/;"	f
test2	lock_tester.cc	/^test2(void *x) $/;"	f
test3	lock_tester.cc	/^test3(void *x)$/;"	f
test4	lock_tester.cc	/^test4(void *x)$/;"	f
test5	lock_tester.cc	/^test5(void *x)$/;"	f
test_net_repairreq	rsm.cc	/^rsm::test_net_repairreq(int heal, int &r)$/;"	f	class:rsm
testmarshall	rpc/rpctest.cc	/^testmarshall()$/;"	f
testsvr	rsm.h	/^  rpcs *testsvr;$/;"	m	class:rsm
th_	rpc/connection.h	/^		pthread_t th_;$/;"	m	class:tcpsconn
th_	rpc/pollmgr.h	/^		pthread_t th_;$/;"	m	class:PollMgr
th_	rpc/thr_pool.h	/^		std::vector<pthread_t> th_;$/;"	m	class:ThrPool
timeout_failure	rpc/rpc.h	/^		static const int timeout_failure = -1;$/;"	m	class:rpc_const
to	rpc/rpc.h	/^			int to;$/;"	m	struct:rpcc::TO
to	rpc/rpc.h	/^		static TO to(int x) { TO t; t.to = x; return t;}$/;"	f	class:rpcc
to_max	rpc/rpc.cc	/^const rpcc::TO rpcc::to_max = { 120000 };$/;"	m	class:rpcc	file:
to_max	rpc/rpc.h	/^		static const TO to_max;$/;"	m	class:rpcc
to_min	rpc/rpc.cc	/^const rpcc::TO rpcc::to_min = { 1000 };$/;"	m	class:rpcc	file:
to_min	rpc/rpc.h	/^		static const TO to_min;$/;"	m	class:rpcc
tprintf	tprintf.h	4;"	d
transferdonereq	rsm.cc	/^rsm::transferdonereq(std::string m, unsigned vid, int &)$/;"	f	class:rsm
transferdonereq	rsm_protocol.h	/^    transferdonereq,$/;"	e	enum:rsm_protocol::rpc_numbers
transferreq	rsm.cc	/^rsm::transferreq(std::string src, viewstamp last, unsigned vid, $/;"	f	class:rsm
transferreq	rsm_protocol.h	/^    transferreq,$/;"	e	enum:rsm_protocol::rpc_numbers
transferres	rsm_protocol.h	/^  struct transferres {$/;"	s	class:rsm_protocol
un	rpc/rpc.h	/^			unmarshall *un;$/;"	m	struct:rpcc::caller
unlink	yfs_client.cc	/^yfs_client::unlink(inum parent, const char *name) $/;"	f	class:yfs_client
unlink1	test-lab-3-b.c	/^unlink1(const char *d, const char *f)$/;"	f
unlink1	test-lab-3-c.c	/^unlink1(const char *d, const char *f)$/;"	f
unlinkn	test-lab-3-b.c	/^unlinkn(const char *d, const char *prefix, int nf)$/;"	f
unlinkn	test-lab-3-c.c	/^unlinkn(const char *d, const char *prefix, int nf)$/;"	f
unmarshal_args_failure	rpc/rpc.h	/^		static const int unmarshal_args_failure = -2;$/;"	m	class:rpc_const
unmarshal_reply_failure	rpc/rpc.h	/^		static const int unmarshal_reply_failure = -3;$/;"	m	class:rpc_const
unmarshal_state	lock_server_cache_rsm.cc	/^lock_server_cache_rsm::unmarshal_state(std::string state)$/;"	f	class:lock_server_cache_rsm
unmarshall	rpc/marshall.h	/^		unmarshall(): _buf(NULL),_sz(0),_ind(0),_ok(false) {}$/;"	f	class:unmarshall
unmarshall	rpc/marshall.h	/^		unmarshall(char *b, int sz): _buf(b),_sz(sz),_ind(),_ok(true) {}$/;"	f	class:unmarshall
unmarshall	rpc/marshall.h	/^		unmarshall(const std::string &s) : _buf(NULL),_sz(0),_ind(0),_ok(false) $/;"	f	class:unmarshall
unmarshall	rpc/marshall.h	/^class unmarshall {$/;"	c
unpack	rpc/rpc.cc	/^unmarshall::unpack(int *x)$/;"	f	class:unmarshall
unpack_reply_header	rpc/marshall.h	/^		void unpack_reply_header(reply_header *h) {$/;"	f	class:unmarshall
unpack_req_header	rpc/marshall.h	/^		void unpack_req_header(req_header *h) {$/;"	f	class:unmarshall
unwatch_fd	rpc/pollmgr.cc	/^EPollAIO::unwatch_fd(int fd, poll_flag flag)$/;"	f	class:EPollAIO
unwatch_fd	rpc/pollmgr.cc	/^SelectAIO::unwatch_fd(int fd, poll_flag flag)$/;"	f	class:SelectAIO
update_xid_rep	rpc/rpc.cc	/^rpcc::update_xid_rep(unsigned int xid)$/;"	f	class:rpcc
updatestat	rpc/rpc.cc	/^rpcs::updatestat(unsigned int proc)$/;"	f	class:rpcs
useful	rpc/pollmgr.h	/^		static int useful;$/;"	m	class:PollMgr
useless	rpc/pollmgr.h	/^		static int useless;$/;"	m	class:PollMgr
v	paxos_protocol.h	/^    std::string v;$/;"	m	struct:paxos_protocol::acceptarg
v	paxos_protocol.h	/^    std::string v;$/;"	m	struct:paxos_protocol::decidearg
v_a	paxos.h	/^  std::string v_a;	\/\/ value of highest proposal accepted$/;"	m	class:acceptor
v_a	paxos_protocol.h	/^    std::string v_a;$/;"	m	struct:paxos_protocol::prepareres
value	config.cc	/^config::value(std::vector<std::string> m)$/;"	f	class:config
value	lang/algorithm.h	/^    static const int value = A > B ? A : B;$/;"	m	struct:static_max
value	paxos.h	/^  std::string value(unsigned instance) { return values[instance]; }$/;"	f	class:acceptor
values	paxos.h	/^  std::map<unsigned,std::string> values;	\/\/ vals of each instance$/;"	m	class:acceptor
vc	config.h	/^  config_view_change *vc;$/;"	m	class:config
verify_client_h	lang/verify.h	4;"	d
vid	config.h	/^  unsigned vid() { return myvid; }$/;"	f	class:config
vid	rsm_protocol.h	/^  unsigned int vid;$/;"	m	struct:viewstamp
vid_commit	rsm.h	/^  unsigned vid_commit;  \/\/ Latest view id that is known to rsm layer$/;"	m	class:rsm
vid_insync	rsm.h	/^  unsigned vid_insync;  \/\/ The view id that this node is synchronizing for$/;"	m	class:rsm
viewstamp	rsm_protocol.h	/^  viewstamp (unsigned int _vid = 0, unsigned int _seqno = 0) {$/;"	f	struct:viewstamp
viewstamp	rsm_protocol.h	/^struct viewstamp {$/;"	s
wait_and_check_expected_view	rsm_tester.pl	/^sub wait_and_check_expected_view($) {$/;"	s
wait_for_view_change	rsm_tester.pl	/^sub wait_for_view_change {$/;"	s
wait_loop	rpc/pollmgr.cc	/^PollMgr::wait_loop()$/;"	f	class:PollMgr
wait_ready	rpc/pollmgr.cc	/^EPollAIO::wait_ready(std::vector<int> *readable, std::vector<int> *writable)$/;"	f	class:EPollAIO
wait_ready	rpc/pollmgr.cc	/^SelectAIO::wait_ready(std::vector<int> *readable, std::vector<int> *writable)$/;"	f	class:SelectAIO
waiters_	rpc/connection.h	/^		int waiters_;$/;"	m	class:connection
waitpid_to	rsm_tester.pl	/^sub waitpid_to {$/;"	s
waitqueue	lock_client_cache.h	/^		pthread_cond_t waitqueue;$/;"	m	struct:lock_client_cache::lock_entry
waitset	lock_server_cache.h	/^		std::set<std::string> waitset;$/;"	m	struct:lock_server_cache::lock_entry
watch_fd	rpc/pollmgr.cc	/^EPollAIO::watch_fd(int fd, poll_flag flag)$/;"	f	class:EPollAIO
watch_fd	rpc/pollmgr.cc	/^SelectAIO::watch_fd(int fd, poll_flag flag)$/;"	f	class:SelectAIO
wfds_	rpc/pollmgr.h	/^		fd_set wfds_;$/;"	m	class:SelectAIO
wpdu_	rpc/connection.h	/^		charbuf wpdu_;$/;"	m	class:connection
write	yfs_client.cc	/^yfs_client::write(inum inum, off_t off, size_t size, const char *buf)$/;"	f	class:yfs_client
write1	test-lab-3-b.c	/^write1(const char *d, const char *f, int start, int n, char c)$/;"	f
write_cb	rpc/connection.cc	/^connection::write_cb(int s)$/;"	f	class:connection
writeat	test-lab-2-b.pl	/^sub writeat {$/;"	s
writeone	test-lab-2-b.pl	/^sub writeone {$/;"	s
writepdu	rpc/connection.cc	/^connection::writepdu()$/;"	f	class:connection
xid	lock_client_cache_rsm.h	/^  lock_protocol::xid_t xid;$/;"	m	class:lock_client_cache_rsm
xid	rpc/marshall.h	/^	int xid;$/;"	m	struct:reply_header
xid	rpc/marshall.h	/^	int xid;$/;"	m	struct:req_header
xid	rpc/rpc.h	/^			unsigned int xid;$/;"	m	struct:rpcc::caller
xid	rpc/rpc.h	/^		unsigned int xid;$/;"	m	struct:rpcs::reply_t
xid	rpc/rpc.h	/^                    int xid;$/;"	m	struct:rpcc::request
xid_	rpc/rpc.h	/^		unsigned int xid_;$/;"	m	class:rpcc
xid_rep	rpc/marshall.h	/^	int xid_rep;$/;"	m	struct:req_header
xid_rep_done_	rpc/rpc.h	/^                int xid_rep_done_;$/;"	m	class:rpcc
xid_rep_window_	rpc/rpc.h	/^		std::list<unsigned int> xid_rep_window_;$/;"	m	class:rpcc
xid_t	lock_protocol.h	/^  typedef unsigned long long xid_t;$/;"	t	class:lock_protocol
xxstatus	extent_protocol.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR };$/;"	g	class:extent_protocol
xxstatus	lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	g	class:lock_protocol
xxstatus	lock_protocol.h	/^  enum xxstatus { OK, RPCERR };$/;"	g	class:rlock_protocol
xxstatus	paxos_protocol.h	/^  enum xxstatus { OK, ERR };$/;"	g	class:paxos_protocol
xxstatus	rsm_protocol.h	/^  enum xxstatus { OK, ERR, BUSY};$/;"	g	class:rsm_protocol
xxstatus	rsm_protocol.h	/^  enum xxstatus { OK, ERR, NOTPRIMARY, BUSY};$/;"	g	class:rsm_client_protocol
xxstatus	rsm_protocol.h	/^  enum xxstatus { OK, ERR};$/;"	g	class:rsm_test_protocol
xxstatus	yfs_client.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR, EXIST };$/;"	g	class:yfs_client
yfs	fuse.cc	/^yfs_client *yfs;$/;"	v
yfs_client	GNUmakefile	/^yfs_client=yfs_client.cc extent_client.cc fuse.cc$/;"	m
yfs_client	yfs_client.cc	/^yfs_client::yfs_client(std::string extent_dst, std::string lock_dst)$/;"	f	class:yfs_client
yfs_client	yfs_client.h	/^class yfs_client {$/;"	c
yfs_client_h	yfs_client.h	2;"	d
yyy	rpc/method_thread.h	/^				static void *yyy(void *vvv) {$/;"	f	class:__anon4::XXX
~EPollAIO	rpc/pollmgr.cc	/^EPollAIO::~EPollAIO()$/;"	f	class:EPollAIO
~PollMgr	rpc/pollmgr.cc	/^PollMgr::~PollMgr()$/;"	f	class:PollMgr
~ScopedLock	rpc/slock.h	/^		~ScopedLock() {$/;"	f	struct:ScopedLock
~ScopedLockClient	yfs_client.h	/^		~ScopedLockClient() {$/;"	f	class:ScopedLockClient
~SelectAIO	rpc/pollmgr.cc	/^SelectAIO::~SelectAIO()$/;"	f	class:SelectAIO
~ThrPool	rpc/thr_pool.cc	/^ThrPool::~ThrPool()$/;"	f	class:ThrPool
~acceptor	paxos.h	/^  ~acceptor() {};$/;"	f	class:acceptor
~aio_callback	rpc/pollmgr.h	/^		virtual ~aio_callback() {}$/;"	f	class:aio_callback
~aio_mgr	rpc/pollmgr.h	/^		virtual ~aio_mgr() {}$/;"	f	class:aio_mgr
~caller	rpc/rpc.cc	/^rpcc::caller::~caller()$/;"	f	class:rpcc::caller
~chanmgr	rpc/connection.h	/^		virtual ~chanmgr() {}$/;"	f	class:chanmgr
~config_view_change	config.h	/^  virtual ~config_view_change() {};$/;"	f	class:config_view_change
~connection	rpc/connection.cc	/^connection::~connection()$/;"	f	class:connection
~fifo	rpc/fifo.h	/^fifo<T>::~fifo()$/;"	f	class:fifo
~handle	handle.cc	/^handle::~handle() $/;"	f	class:handle
~handler	rpc/rpc.h	/^		virtual ~handler() { }$/;"	f	class:handler
~lock	lock_protocol.h	/^	~lock(){};$/;"	f	class:lock
~lock_client	lock_client.h	/^  virtual ~lock_client() {};$/;"	f	class:lock_client
~lock_client_cache	lock_client_cache.h	/^  virtual ~lock_client_cache() {};$/;"	f	class:lock_client_cache
~lock_client_cache_rsm	lock_client_cache_rsm.h	/^  virtual ~lock_client_cache_rsm() {};$/;"	f	class:lock_client_cache_rsm
~lock_release_user	lock_client_cache.h	/^  virtual ~lock_release_user() {};$/;"	f	class:lock_release_user
~lock_release_user	lock_client_cache_rsm.h	/^  virtual ~lock_release_user() {};$/;"	f	class:lock_release_user
~lock_server	lock_server.h	/^  ~lock_server() {};$/;"	f	class:lock_server
~marshall	rpc/marshall.h	/^		~marshall() { $/;"	f	class:marshall
~paxos_change	paxos.h	/^  virtual ~paxos_change() {};$/;"	f	class:paxos_change
~proposer	paxos.h	/^  ~proposer() {};$/;"	f	class:proposer
~rpcc	rpc/rpc.cc	/^rpcc::~rpcc()$/;"	f	class:rpcc
~rpcs	rpc/rpc.cc	/^rpcs::~rpcs()$/;"	f	class:rpcs
~rsm	rsm.h	/^  ~rsm() {};$/;"	f	class:rsm
~rsm_state_transfer	rsm_state_transfer.h	/^  virtual ~rsm_state_transfer() {};$/;"	f	class:rsm_state_transfer
~rsmtest_client	rsmtest_client.h	/^  virtual ~rsmtest_client() {};$/;"	f	class:rsmtest_client
~tcpsconn	rpc/connection.cc	/^tcpsconn::~tcpsconn()$/;"	f	class:tcpsconn
~unmarshall	rpc/marshall.h	/^		~unmarshall() {$/;"	f	class:unmarshall
